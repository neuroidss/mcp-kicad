# __init__.py
```__init__.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from kipy.kicad import KiCad

__all__ = ("KiCad",)

```

# board_types.py
```board_types.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from deprecated import deprecated
from typing import Dict, Sequence, Optional, Union
from google.protobuf.message import Message
from google.protobuf.any_pb2 import Any

from kipy.proto.common.types import KIID
from kipy.proto.common.types import base_types_pb2
from kipy.proto.common.types.base_types_pb2 import LockedState
from kipy.proto.board import board_commands_pb2, board_types_pb2
from kipy.common_types import (
    GraphicAttributes,
    TextAttributes,
    LibraryIdentifier,
    Segment,
    Arc,
    Circle,
    Rectangle,
    Polygon,
    Bezier,
    SheetPath,
    Text,
    TextBox,
)
from kipy.geometry import (
    Angle,
    Box2,
    Vector2,
    Vector3D,
    PolygonWithHoles,
    arc_center,
    arc_radius,
    arc_start_angle,
    arc_end_angle,
    normalize_angle_radians,
)
from kipy.util import unpack_any
from kipy.util.board_layer import is_copper_layer, iter_copper_layers
from kipy.util.units import from_mm
from kipy.wrapper import Item, Wrapper

# Re-exported protobuf enum types
from kipy.proto.board.board_types_pb2 import (  # noqa
    PSS_CIRCLE,
    PST_NORMAL,
    BoardLayer,
    ChamferedRectCorners,
    DrillShape,
    IslandRemovalMode,
    PadType,
    PadStackShape,
    SolderMaskMode,
    SolderPasteMode,
    TeardropType,
    UnconnectedLayerRemoval,
    ViaType,
    ZoneBorderStyle,
    ZoneConnectionStyle,
    ZoneFillMode,
    ZoneType,
)

from kipy.proto.board.board_commands_pb2 import (  # noqa
    InactiveLayerDisplayMode,
    NetColorDisplayMode,
    BoardFlipMode,
    RatsnestDisplayMode
)

class BoardItem(Item):
    @property
    def id(self) -> KIID:
        return self.proto.id


class Net(Wrapper):
    def __init__(self, proto: Optional[board_types_pb2.Net] = None):
        self._proto = board_types_pb2.Net()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return f"Net(name={self.name}, code={self.code})"

    @property
    def name(self) -> str:
        return self._proto.name

    @name.setter
    def name(self, name: str):
        self._proto.name = name

    @property
    @deprecated("This property will be removed in KiCad 10; API clients should not rely on net codes")
    def code(self) -> int:
        """
        .. deprecated:: 0.4.0
        """
        return self._proto.code.value

    def __eq__(self, other):
        if isinstance(other, Net):
            return self.name == other.name
        return NotImplemented


class Track(BoardItem):
    """Represents a straight track segment"""

    def __init__(self, proto: Optional[board_types_pb2.Track] = None,
                 proto_ref: Optional[board_types_pb2.Track] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Track()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return (
            f"Track(start={self.start}, end={self.end}, layer={BoardLayer.Name(self.layer)}, "
            f"net={self.net.name})"
        )

    @property
    def net(self) -> Net:
        return Net(self._proto.net)

    @net.setter
    def net(self, net: Net):
        self._proto.net.CopyFrom(net.proto)

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def start(self) -> Vector2:
        return Vector2(self._proto.start)

    @start.setter
    def start(self, point: Vector2):
        self._proto.start.CopyFrom(point.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._proto.end)

    @end.setter
    def end(self, point: Vector2):
        self._proto.end.CopyFrom(point.proto)

    @property
    def width(self) -> int:
        return self._proto.width.value_nm

    @width.setter
    def width(self, width: int):
        self._proto.width.value_nm = width

    def length(self) -> float:
        """Calculates track length in nanometers"""
        return (self.end - self.start).length()


class ArcTrack(BoardItem):
    """Represents an arc track segment"""

    def __init__(self, proto: Optional[board_types_pb2.Arc] = None,
                 proto_ref: Optional[board_types_pb2.Arc] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Arc()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return (
            f"ArcTrack(start={self.start}, mid={self.mid}, end={self.end}, "
            f"layer={BoardLayer.Name(self.layer)}, net={self.net.name})"
        )

    @property
    def net(self) -> Net:
        return Net(self._proto.net)

    @net.setter
    def net(self, net: Net):
        self._proto.net.CopyFrom(net.proto)

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def start(self) -> Vector2:
        return Vector2(self._proto.start)

    @start.setter
    def start(self, point: Vector2):
        self._proto.start.CopyFrom(point.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._proto.end)

    @end.setter
    def end(self, point: Vector2):
        self._proto.end.CopyFrom(point.proto)

    @property
    def width(self) -> int:
        return self._proto.width.value_nm

    @width.setter
    def width(self, width: int):
        self._proto.width.value_nm = width

    @property
    def mid(self) -> Vector2:
        return Vector2(self._proto.mid)

    @mid.setter
    def mid(self, point: Vector2):
        self._proto.mid.CopyFrom(point.proto)

    def center(self) -> Optional[Vector2]:
        """
        Calculates the center of the arc.  Uses a different algorithm than KiCad so may have
        slightly different results.  The KiCad API preserves the start, middle, and end points of
        the arc, so any other properties such as the center point and angles must be calculated

        :return: The center of the arc, or None if the arc is degenerate
        """
        # TODO we may want to add an API call to get KiCad to calculate this for us,
        # for situations where matching KiCad's behavior exactly is important
        return arc_center(self.start, self.mid, self.end)

    def radius(self) -> float:
        """
        Calculates the radius of the arc.  Uses a different algorithm than KiCad so may have
        slightly different results.  The KiCad API preserves the start, middle, and end points of
        the arc, so any other properties such as the center point and angles must be calculated

        :return: The radius of the arc, or 0 if the arc is degenerate
        """
        # TODO we may want to add an API call to get KiCad to calculate this for us,
        # for situations where matching KiCad's behavior exactly is important
        return arc_radius(self.start, self.mid, self.end)

    def start_angle(self) -> Optional[float]:
        return arc_start_angle(self.start, self.mid, self.end)

    def end_angle(self) -> Optional[float]:
        return arc_end_angle(self.start, self.mid, self.end)

    def length(self) -> float:
        """Calculates arc track length in nanometers

        :return: The length of the arc, or the distance between the start and end points if the
                 arc is degenerate
        .. versionadded:: 0.3.0"""
        start = self.start_angle()
        end = self.end_angle()

        if start is None or end is None:
            return (self.end - self.start).length()

        delta_angle = normalize_angle_radians(end - start)
        return delta_angle*self.radius()

    def bounding_box(self) -> Box2:
        box = Box2()
        box.merge(self.start)
        box.merge(self.end)
        box.merge(self.mid)
        return box


class BoardShape(BoardItem):
    """Represents a graphic shape on a board or footprint"""

    def __init__(self, proto: Optional[board_types_pb2.BoardGraphicShape] = None,
                 proto_ref: Optional[board_types_pb2.BoardGraphicShape] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardGraphicShape()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def id(self) -> KIID:
        return self._proto.id

    @property
    def locked(self) -> bool:
        return self._proto.locked == LockedState.LS_LOCKED

    @locked.setter
    def locked(self, locked: bool):
        self._proto.locked = {
            True: LockedState.LS_LOCKED,
            False: LockedState.LS_UNLOCKED,
        }.get(locked, LockedState.LS_UNLOCKED)

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def net(self) -> Net:
        return Net(self._proto.net)

    @net.setter
    def net(self, net: Net):
        self._proto.net.CopyFrom(net.proto)

    @property
    def attributes(self) -> GraphicAttributes:
        return GraphicAttributes(proto_ref=self._proto.shape.attributes)

    @attributes.setter
    def attributes(self, attributes: GraphicAttributes):
        self._proto.shape.attributes.CopyFrom(attributes.proto)

    def move(self, delta: Vector2):
        raise NotImplementedError(f"move() not implemented for {self.__class__.__name__}")

    def rotate(self, angle: Angle, center: Vector2):
        raise NotImplementedError(f"rotate() not implemented for {self.__class__.__name__}")

class BoardSegment(BoardShape, Segment):
    """Represents a graphic line segment (not a track) on a board or footprint"""

    def __init__(self, proto: Optional[board_types_pb2.BoardGraphicShape] = None,
                 proto_ref: Optional[board_types_pb2.BoardGraphicShape] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardGraphicShape()

        if proto is not None:
            assert proto.shape.WhichOneof("geometry") == "segment"
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self._proto.shape.segment.SetInParent()

        Segment.__init__(self, proto_ref=self._proto.shape)

    def __repr__(self) -> str:
        net_repr = (
            f", net={self.net.name}"
            if is_copper_layer(self.layer)
            and self._proto.HasField("net")
            else ""
        )
        return (
            f"BoardSegment(start={self.start}, end={self.end}, layer={BoardLayer.Name(self.layer)}"
            f"{net_repr})"
        )

    def move(self, delta: Vector2):
        """Moves the segment by the given delta vector"""
        self.start += delta
        self.end += delta

    def rotate(self, angle: Angle, center: Vector2):
        """Rotates the segment around the given center point by the given angle"""
        self.start = self.start.rotate(angle, center)
        self.end = self.end.rotate(angle, center)

class BoardArc(BoardShape, Arc):
    """Represents a graphic arc (not a track) on a board or footprint"""

    def __init__(self, proto: Optional[board_types_pb2.BoardGraphicShape] = None,
                 proto_ref: Optional[board_types_pb2.BoardGraphicShape] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardGraphicShape()

        if proto is not None:
            assert proto.shape.WhichOneof("geometry") == "arc"
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self._proto.shape.arc.SetInParent()

        Arc.__init__(self, proto_ref=self._proto.shape)

    def __repr__(self) -> str:
        net_repr = (
            f", net={self.net.name}"
            if is_copper_layer(self.layer)
            and self._proto.HasField("net")
            else ""
        )
        return (
            f"BoardArc(start={self.start}, mid={self.mid}, end={self.end}, "
            f"layer={BoardLayer.Name(self.layer)}{net_repr})"
        )

    def move(self, delta: Vector2):
        """Moves the arc by the given delta vector"""
        self.start += delta
        self.mid += delta
        self.end += delta

    def rotate(self, angle: Angle, center: Vector2):
        """Rotates the arc around the given center point by the given angle"""
        self.start = self.start.rotate(angle, center)
        self.mid = self.mid.rotate(angle, center)
        self.end = self.end.rotate(angle, center)

class BoardCircle(BoardShape, Circle):
    """Represents a graphic circle on a board or footprint"""

    def __init__(self, proto: Optional[board_types_pb2.BoardGraphicShape] = None,
                 proto_ref: Optional[board_types_pb2.BoardGraphicShape] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardGraphicShape()

        if proto is not None:
            assert proto.shape.WhichOneof("geometry") == "circle"
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self._proto.shape.circle.SetInParent()

        Circle.__init__(self, proto_ref=self._proto.shape)

    def __repr__(self) -> str:
        net_repr = (
            f", net={self.net.name}"
            if is_copper_layer(self.layer)
            and self._proto.HasField("net")
            else ""
        )
        return (
            f"BoardCircle(center={self.center}, radius_point={self.radius_point}, "
            f"layer={BoardLayer.Name(self.layer)}{net_repr})"
        )

    def move(self, delta: Vector2):
        """Moves the circle by the given delta vector"""
        self.center += delta
        self.radius_point += delta

    def rotate(self, angle: Angle, center: Vector2):
        pass

class BoardRectangle(BoardShape, Rectangle):
    """Represents a graphic rectangle on a board or footprint"""

    def __init__(self, proto: Optional[board_types_pb2.BoardGraphicShape] = None,
                 proto_ref: Optional[board_types_pb2.BoardGraphicShape] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardGraphicShape()

        if proto is not None:
            assert proto.shape.WhichOneof("geometry") == "rectangle"
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self._proto.shape.rectangle.SetInParent()

        Rectangle.__init__(self, proto_ref=self._proto.shape)

    def __repr__(self) -> str:
        net_repr = (
            f", net={self.net.name}"
            if is_copper_layer(self.layer)
            and self._proto.HasField("net")
            else ""
        )
        return (
            f"BoardRectangle(top_left={self.top_left}, bottom_right={self.bottom_right}, "
            f"layer={BoardLayer.Name(self.layer)}{net_repr}"
        )

    def move(self, delta: Vector2):
        """Moves the rectangle by the given delta vector"""
        self.top_left += delta
        self.bottom_right += delta

    def rotate(self, angle: Angle, center: Vector2):
        """Rotates the rectangle around the given center point by the given angle"""
        self.top_left = self.top_left.rotate(angle, center)
        self.bottom_right = self.bottom_right.rotate(angle, center)

class BoardPolygon(BoardShape, Polygon):
    """Represents a graphic polygon on a board or footprint"""

    def __init__(self, proto: Optional[board_types_pb2.BoardGraphicShape] = None,
                 proto_ref: Optional[board_types_pb2.BoardGraphicShape] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardGraphicShape()

        if proto is not None:
            assert proto.shape.WhichOneof("geometry") == "polygon"
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self._proto.shape.polygon.SetInParent()

        Polygon.__init__(self, proto_ref=self._proto.shape)

    def __repr__(self) -> str:
        net_repr = (
            f", net={self.net.name}"
            if is_copper_layer(self.layer)
            and self._proto.HasField("net")
            else ""
        )
        return (
            f"BoardPolygon(points={self.polygons}, layer={BoardLayer.Name(self.layer)}"
            f"{net_repr})"
        )

    def move(self, delta: Vector2):
        """Moves the polygon by the given delta vector"""
        for polygon in self.polygons:
            polygon.move(delta)

    def rotate(self, angle: Angle, center: Vector2):
        """Rotates the polygon around the given center point by the given angle"""
        for polygon in self.polygons:
            polygon.rotate(angle, center)

class BoardBezier(BoardShape, Bezier):
    """Represents a graphic bezier curve on a board or footprint"""

    def __init__(self, proto: Optional[board_types_pb2.BoardGraphicShape] = None,
                 proto_ref: Optional[board_types_pb2.BoardGraphicShape] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardGraphicShape()

        if proto is not None:
            assert proto.shape.WhichOneof("geometry") == "bezier"
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self._proto.shape.bezier.SetInParent()

        Bezier.__init__(self, proto_ref=self._proto.shape)

    def __repr__(self) -> str:
        net_repr = (
            f", net={self.net.name}"
            if is_copper_layer(self.layer)
            and self._proto.HasField("net")
            else ""
        )
        return (
            f"BoardBezier(start={self.start}, control1={self.control1}, control2={self.control2}, "
            f"end={self.end}, layer={BoardLayer.Name(self.layer)}{net_repr})"
        )

    def move(self, delta: Vector2):
        """Moves the bezier curve by the given delta vector"""
        self.start += delta
        self.control1 += delta
        self.control2 += delta
        self.end += delta

    def rotate(self, angle: Angle, center: Vector2):
        """Rotates the bezier curve around the given center point by the given angle"""
        self.start = self.start.rotate(angle, center)
        self.control1 = self.control1.rotate(angle, center)
        self.control2 = self.control2.rotate(angle, center)
        self.end = self.end.rotate(angle, center)

def to_concrete_board_shape(shape: BoardShape) -> Optional[BoardShape]:
    cls = {
        "segment": BoardSegment,
        "arc": BoardArc,
        "circle": BoardCircle,
        "rectangle": BoardRectangle,
        "polygon": BoardPolygon,
        "bezier": BoardBezier,
        None: None,
    }.get(shape._proto.shape.WhichOneof("geometry"), None)

    return cls(proto_ref=shape._proto) if cls is not None else None

class BoardText(BoardItem):
    """Represents a free text object, or the text component of a field"""

    def __init__(
        self,
        proto: Optional[board_types_pb2.BoardText] = None,
        proto_ref: Optional[board_types_pb2.BoardText] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardText()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return f"BoardText(value={self.value}, position={self.position}, layer={BoardLayer.Name(self.layer)})"

    def as_text(self) -> Text:
        """Returns a base Text object using the same data as this BoardText"""
        return Text(self._proto.text)

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def id(self) -> KIID:
        return self._proto.id

    @property
    def locked(self) -> bool:
        return self._proto.locked == LockedState.LS_LOCKED

    @locked.setter
    def locked(self, locked: bool):
        self._proto.locked = {
            True: LockedState.LS_LOCKED,
            False: LockedState.LS_UNLOCKED,
        }.get(locked, LockedState.LS_UNLOCKED)

    @property
    def position(self) -> Vector2:
        return Vector2(self._proto.text.position)

    @position.setter
    def position(self, pos: Vector2):
        self._proto.text.position.CopyFrom(pos.proto)

    @property
    def value(self) -> str:
        return self._proto.text.text

    @value.setter
    def value(self, text: str):
        self._proto.text.text = text

    @property
    def attributes(self) -> TextAttributes:
        return TextAttributes(proto_ref=self._proto.text.attributes)

    @attributes.setter
    def attributes(self, attributes: TextAttributes):
        self._proto.text.attributes.CopyFrom(attributes.proto)

class BoardTextBox(BoardItem):
    """Represents a text box on a board"""

    def __init__(self, proto: Optional[board_types_pb2.BoardTextBox] = None,
                 proto_ref: Optional[board_types_pb2.BoardTextBox] = None,):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.BoardTextBox()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return (
            f"BoardTextBox(value={self.value}, top_left={self.top_left}, "
            f"bottom_right={self.bottom_right}, layer={BoardLayer.Name(self.layer)})"
        )

    def as_textbox(self) -> TextBox:
        """Returns a base TextBox object using the same data as this BoardText"""
        return TextBox(self._proto.textbox)

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def locked(self) -> bool:
        return self._proto.locked == LockedState.LS_LOCKED

    @locked.setter
    def locked(self, locked: bool):
        self._proto.locked = {
            True: LockedState.LS_LOCKED,
            False: LockedState.LS_UNLOCKED,
        }.get(locked, LockedState.LS_UNLOCKED)

    @property
    def top_left(self) -> Vector2:
        return Vector2(self._proto.textbox.top_left)

    @top_left.setter
    def top_left(self, pos: Vector2):
        self._proto.textbox.top_left.CopyFrom(pos.proto)

    @property
    def bottom_right(self) -> Vector2:
        return Vector2(self._proto.textbox.bottom_right)

    @bottom_right.setter
    def bottom_right(self, pos: Vector2):
        self._proto.textbox.bottom_right.CopyFrom(pos.proto)

    @property
    def attributes(self) -> TextAttributes:
        return TextAttributes(proto_ref=self._proto.textbox.attributes)

    @attributes.setter
    def attributes(self, attributes: TextAttributes):
        self._proto.textbox.attributes.CopyFrom(attributes.proto)

    @property
    def value(self) -> str:
        return self._proto.textbox.text

    @value.setter
    def value(self, text: str):
        self._proto.textbox.text = text


class Field(BoardItem):
    """Represents a footprint field"""

    def __init__(
        self,
        proto: Optional[board_types_pb2.Field] = None,
        proto_ref: Optional[board_types_pb2.Field] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Field()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return f"Field(name={self.name}, text={self.text}, layer={BoardLayer.Name(self.layer)})"

    @property
    def field_id(self) -> int:
        return self._proto.id.id

    @property
    def name(self) -> str:
        return self._proto.name

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.text.layer

    @property
    def text(self) -> BoardText:
        return BoardText(proto_ref=self._proto.text)

    @text.setter
    def text(self, text: BoardText):
        self._proto.text.CopyFrom(text.proto)

    @property
    def visible(self) -> bool:
        """
        .. versionadded:: 0.3.0 with KiCad 9.0.1
        """
        return self._proto.visible

    @visible.setter
    def visible(self, visible: bool):
        self._proto.visible = visible


class ThermalSpokeSettings(Wrapper):
    def __init__(
        self,
        proto: Optional[board_types_pb2.ThermalSpokeSettings] = None,
        proto_ref: Optional[board_types_pb2.ThermalSpokeSettings] = None,
    ):
        self._proto = (
            proto_ref
            if proto_ref is not None
            else board_types_pb2.ThermalSpokeSettings()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def width(self) -> Optional[int]:
        if self._proto.HasField("width"):
            return self._proto.width.value_nm
        return None

    @width.setter
    def width(self, width: int):
        if width is None:
            self._proto.ClearField("width")
        else:
            self._proto.width.value_nm = width

    @property
    def angle(self) -> Angle:
        return Angle(self._proto.angle)

    @angle.setter
    def angle(self, angle: Angle):
        self._proto.angle.CopyFrom(angle.proto)

    @property
    def gap(self) -> Optional[int]:
        if self._proto.HasField("gap"):
            return self._proto.gap.value_nm
        return None

    @gap.setter
    def gap(self, gap: Optional[int]):
        if gap is None:
            self._proto.ClearField("gap")
        else:
            self._proto.gap.value_nm = gap


class ZoneConnectionSettings(Wrapper):
    def __init__(
        self,
        proto: Optional[board_types_pb2.ZoneConnectionSettings] = None,
        proto_ref: Optional[board_types_pb2.ZoneConnectionSettings] = None,
    ):
        self._proto = (
            proto_ref
            if proto_ref is not None
            else board_types_pb2.ZoneConnectionSettings()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def zone_connection(self) -> ZoneConnectionStyle.ValueType:
        return self._proto.zone_connection

    @zone_connection.setter
    def zone_connection(self, zone_connection: ZoneConnectionStyle.ValueType):
        self._proto.zone_connection = zone_connection

    @property
    def thermal_spokes(self) -> ThermalSpokeSettings:
        return ThermalSpokeSettings(self._proto.thermal_spokes)


class SolderMaskOverrides(Wrapper):
    def __init__(
        self,
        proto: Optional[board_types_pb2.SolderMaskOverrides] = None,
        proto_ref: Optional[board_types_pb2.SolderMaskOverrides] = None,
    ):
        self._proto = (
            proto_ref
            if proto_ref is not None
            else board_types_pb2.SolderMaskOverrides()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def solder_mask_margin(self) -> int:
        return self._proto.solder_mask_margin.value_nm

    @solder_mask_margin.setter
    def solder_mask_margin(self, margin_nm: int):
        self._proto.solder_mask_margin.value_nm = margin_nm


class SolderPasteOverrides(Wrapper):
    def __init__(
        self,
        proto: Optional[board_types_pb2.SolderPasteOverrides] = None,
        proto_ref: Optional[board_types_pb2.SolderPasteOverrides] = None,
    ):
        self._proto = (
            proto_ref
            if proto_ref is not None
            else board_types_pb2.SolderPasteOverrides()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def solder_paste_margin(self) -> int:
        return self._proto.solder_paste_margin.value_nm

    @solder_paste_margin.setter
    def solder_paste_margin(self, margin_nm: int):
        self._proto.solder_paste_margin.value_nm = margin_nm

    @property
    def solder_paste_margin_ratio(self) -> float:
        return self._proto.solder_paste_margin_ratio.value

    @solder_paste_margin_ratio.setter
    def solder_paste_margin_ratio(self, ratio: float):
        self._proto.solder_paste_margin_ratio.value = ratio


class PadStackLayer(Wrapper):
    def __init__(
        self,
        proto: Optional[board_types_pb2.PadStackLayer] = None,
        proto_ref: Optional[board_types_pb2.PadStackLayer] = None,
    ):
        self._proto = (
            proto_ref if proto_ref is not None else board_types_pb2.PadStackLayer()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def shape(self) -> PadStackShape.ValueType:
        return self._proto.shape

    @shape.setter
    def shape(self, shape: PadStackShape.ValueType):
        self._proto.shape = shape

    @property
    def size(self) -> Vector2:
        return Vector2(self._proto.size)

    @size.setter
    def size(self, size: Vector2):
        self._proto.size.CopyFrom(size.proto)

    @property
    def offset(self) -> Vector2:
        return Vector2(self._proto.offset)

    @offset.setter
    def offset(self, offset: Vector2):
        self._proto.offset.CopyFrom(offset.proto)

    @property
    def corner_rounding_ratio(self) -> float:
        return self._proto.corner_rounding_ratio

    @corner_rounding_ratio.setter
    def corner_rounding_ratio(self, ratio: float):
        self._proto.corner_rounding_ratio = ratio

    @property
    def chamfer_ratio(self) -> float:
        return self._proto.chamfer_ratio

    @chamfer_ratio.setter
    def chamfer_ratio(self, ratio: float):
        self._proto.chamfer_ratio = ratio

    @property
    def chamfered_corners(self) -> board_types_pb2.ChamferedRectCorners:
        return self._proto.chamfered_corners

    @property
    def trapezoid_delta(self) -> Vector2:
        return Vector2(self._proto.trapezoid_delta)

    @trapezoid_delta.setter
    def trapezoid_delta(self, delta: Vector2):
        self._proto.trapezoid_delta.CopyFrom(delta.proto)

    @property
    def custom_shapes(self) -> Sequence[BoardShape]:
        return [
            item
            for item in (
                to_concrete_board_shape(BoardShape(shape)) for shape in self._proto.custom_shapes
            )
            if item is not None
        ]

    @custom_shapes.setter
    def custom_shapes(self, shapes: Sequence[BoardShape]):
        del self._proto.custom_shapes[:]
        self._proto.custom_shapes.extend([shape.proto for shape in shapes])

    @property
    def custom_anchor_shape(self) -> PadStackShape.ValueType:
        return self._proto.custom_anchor_shape

    @custom_anchor_shape.setter
    def custom_anchor_shape(self, shape: PadStackShape.ValueType):
        self._proto.custom_anchor_shape = shape

    @property
    def zone_settings(self) -> board_types_pb2.ZoneConnectionSettings:
        return self._proto.zone_settings

    @zone_settings.setter
    def zone_settings(self, settings: board_types_pb2.ZoneConnectionSettings):
        self._proto.zone_settings.CopyFrom(settings)


class DrillProperties(Wrapper):
    def __init__(
        self,
        proto: Optional[board_types_pb2.DrillProperties] = None,
        proto_ref: Optional[board_types_pb2.DrillProperties] = None,
    ):
        self._proto = (
            proto_ref if proto_ref is not None else board_types_pb2.DrillProperties()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def start_layer(self) -> BoardLayer.ValueType:
        return self._proto.start_layer

    @start_layer.setter
    def start_layer(self, layer: BoardLayer.ValueType):
        self._proto.start_layer = layer

    @property
    def end_layer(self) -> BoardLayer.ValueType:
        return self._proto.end_layer

    @end_layer.setter
    def end_layer(self, layer: BoardLayer.ValueType):
        self._proto.end_layer = layer

    @property
    def diameter(self) -> Vector2:
        """The drill diameter, which may also be a milled slot with different X and Y dimensions"""
        return Vector2(self._proto.diameter)

    @diameter.setter
    def diameter(self, diameter: Vector2):
        self._proto.diameter.CopyFrom(diameter.proto)

    @property
    def shape(self) -> board_types_pb2.DrillShape.ValueType:
        return self._proto.shape

    @shape.setter
    def shape(self, shape: board_types_pb2.DrillShape.ValueType):
        self._proto.shape = shape


class PadStackOuterLayer(Wrapper):
    def __init__(
        self,
        proto: Optional[board_types_pb2.PadStackOuterLayer] = None,
        proto_ref: Optional[board_types_pb2.PadStackOuterLayer] = None,
    ):
        self._proto = (
            proto_ref if proto_ref is not None else board_types_pb2.PadStackOuterLayer()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def solder_mask_mode(self) -> board_types_pb2.SolderMaskMode.ValueType:
        return self._proto.solder_mask_mode

    @solder_mask_mode.setter
    def solder_mask_mode(self, mode: board_types_pb2.SolderMaskMode.ValueType):
        self._proto.solder_mask_mode = mode

    @property
    def solder_paste_mode(self) -> board_types_pb2.SolderPasteMode.ValueType:
        return self._proto.solder_paste_mode

    @solder_paste_mode.setter
    def solder_paste_mode(self, mode: board_types_pb2.SolderPasteMode.ValueType):
        self._proto.solder_paste_mode = mode

    @property
    def solder_mask_settings(self) -> SolderMaskOverrides:
        return SolderMaskOverrides(proto_ref=self._proto.solder_mask_settings)

    @solder_mask_settings.setter
    def solder_mask_settings(self, settings: SolderMaskOverrides):
        self._proto.solder_mask_settings.CopyFrom(settings.proto)

    @property
    def solder_paste_settings(self) -> SolderPasteOverrides:
        return SolderPasteOverrides(proto_ref=self._proto.solder_paste_settings)

    @solder_paste_settings.setter
    def solder_paste_settings(self, settings: SolderPasteOverrides):
        self._proto.solder_paste_settings.CopyFrom(settings.proto)


class PadStack(BoardItem):
    def __init__(
        self,
        proto: Optional[board_types_pb2.PadStack] = None,
        proto_ref: Optional[board_types_pb2.PadStack] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.PadStack()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def type(self) -> board_types_pb2.PadStackType.ValueType:
        return self._proto.type

    @type.setter
    def type(self, type: board_types_pb2.PadStackType.ValueType):
        self._proto.type = type

        layer_map = {layer.layer: layer for layer in self._proto.copper_layers}

        required_layers = {
            board_types_pb2.PadStackType.PST_NORMAL: [BoardLayer.BL_F_Cu],
            board_types_pb2.PadStackType.PST_FRONT_INNER_BACK: [
                BoardLayer.BL_F_Cu,
                BoardLayer.BL_In1_Cu,
                BoardLayer.BL_B_Cu,
            ],
            board_types_pb2.PadStackType.PST_CUSTOM: [layer for layer in iter_copper_layers()]
        }.get(type, [])

        for layer in layer_map.keys():
            if layer not in required_layers:
                self._proto.copper_layers.remove(layer_map[layer])

        for layer in required_layers:
            if layer not in layer_map:
                self._add_copper_layer(layer)

    @property
    def layers(self) -> Sequence[BoardLayer.ValueType]:
        return self._proto.layers

    @layers.setter
    def layers(self, layers: Sequence[BoardLayer.ValueType]):
        del self._proto.layers[:]
        self._proto.layers.extend(layers)

    @property
    def drill(self) -> DrillProperties:
        return DrillProperties(proto_ref=self._proto.drill)

    @property
    def unconnected_layer_removal(self) -> UnconnectedLayerRemoval.ValueType:
        return self._proto.unconnected_layer_removal

    @unconnected_layer_removal.setter
    def unconnected_layer_removal(self, removal: UnconnectedLayerRemoval.ValueType):
        self._proto.unconnected_layer_removal = removal

    @property
    def copper_layers(self) -> list[PadStackLayer]:
        return [PadStackLayer(proto_ref=p) for p in self._proto.copper_layers]

    def copper_layer(self, layer: BoardLayer.ValueType) -> Optional[PadStackLayer]:
        for copper_layer in self.copper_layers:
            if copper_layer.layer == layer:
                return copper_layer
        return None

    @property
    def angle(self) -> Angle:
        return Angle(self._proto.angle)

    @angle.setter
    def angle(self, angle: Angle):
        self._proto.angle.CopyFrom(angle.proto)

    @property
    def front_outer_layers(self) -> PadStackOuterLayer:
        return PadStackOuterLayer(proto_ref=self._proto.front_outer_layers)

    @property
    def back_outer_layers(self) -> PadStackOuterLayer:
        return PadStackOuterLayer(proto_ref=self._proto.back_outer_layers)

    @property
    def zone_settings(self) -> ZoneConnectionSettings:
        return ZoneConnectionSettings(proto_ref=self._proto.zone_settings)

    def is_masked(self, layer: BoardLayer.ValueType = BoardLayer.BL_UNDEFINED) -> bool:
        """
        Returns true if the padstack is masked on the given copper layer, or on either layer if
        layer is BL_UNDEFINED.
        """
        if layer == BoardLayer.BL_UNDEFINED:
            return (
                self.front_outer_layers.solder_mask_mode == SolderMaskMode.SMM_MASKED
                or self.back_outer_layers.solder_mask_mode == SolderMaskMode.SMM_MASKED
            )
        elif layer == BoardLayer.BL_F_Cu:
            return self.front_outer_layers.solder_mask_mode == SolderMaskMode.SMM_MASKED
        elif layer == BoardLayer.BL_B_Cu:
            return self.back_outer_layers.solder_mask_mode == SolderMaskMode.SMM_MASKED
        return False

    def _add_copper_layer(self, layer: BoardLayer.ValueType) -> board_types_pb2.PadStackLayer:
        self._proto.copper_layers.append(board_types_pb2.PadStackLayer())
        self._proto.copper_layers[-1].layer = layer
        return self._proto.copper_layers[-1]

class Pad(BoardItem):
    def __init__(self, proto: Optional[board_types_pb2.Pad] = None,
                 proto_ref: Optional[board_types_pb2.Pad] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Pad()

        if proto is not None:
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self.padstack.type = PST_NORMAL

    def __repr__(self) -> str:
        return (
            f"Pad(position={self.position}, net={self.net.name}, "
            f"type={PadType.Name(self.pad_type)})"
        )

    @property
    def id(self) -> KIID:
        return self._proto.id

    @property
    def number(self) -> str:
        return self._proto.number

    @number.setter
    def number(self, number: str):
        self._proto.number = number

    @property
    def position(self) -> Vector2:
        return Vector2(self._proto.position)

    @position.setter
    def position(self, position: Vector2):
        self._proto.position.CopyFrom(position.proto)

    @property
    def net(self) -> Net:
        return Net(self._proto.net)

    @net.setter
    def net(self, net: Net):
        self._proto.net.CopyFrom(net.proto)

    @property
    def pad_type(self) -> PadType.ValueType:
        return self._proto.type

    @property
    def padstack(self) -> PadStack:
        return PadStack(proto_ref=self._proto.pad_stack)


class Via(BoardItem):
    def __init__(self, proto: Optional[board_types_pb2.Via] = None,
                 proto_ref: Optional[board_types_pb2.Via] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Via()

        if proto is not None:
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            self.type = ViaType.VT_THROUGH
            self.padstack.type = PST_NORMAL

    def __repr__(self) -> str:
        return (
            f"Via(position={self.position}, net={self.net.name}, type={ViaType.Name(self.type)}, "
            f"locked={self.locked})"
        )

    @property
    def position(self) -> Vector2:
        return Vector2(self._proto.position)

    @position.setter
    def position(self, position: Vector2):
        self._proto.position.CopyFrom(position.proto)

    @property
    def net(self) -> Net:
        return Net(self._proto.net)

    @net.setter
    def net(self, net: Net):
        self._proto.net.CopyFrom(net.proto)

    @property
    def locked(self) -> bool:
        return self._proto.locked == LockedState.LS_LOCKED

    @locked.setter
    def locked(self, locked: bool):
        self._proto.locked = (
            LockedState.LS_LOCKED if locked else LockedState.LS_UNLOCKED
        )

    @property
    def type(self) -> ViaType.ValueType:
        """The type of the via (through, blind/buried, or micro)

        Setting this property will also update the padstack drill start and end layers as a
        side effect.

        .. versionadded:: 0.3.0 with KiCad 9.0.1
        """
        return self._proto.type

    @type.setter
    def type(self, type: ViaType.ValueType):
        self._proto.type = type

        if (
            type == ViaType.VT_THROUGH
            or self.padstack.drill.start_layer == BoardLayer.BL_UNKNOWN
            or self.padstack.drill.end_layer == BoardLayer.BL_UNKNOWN
        ):
            self.padstack.drill.start_layer = BoardLayer.BL_F_Cu
            self.padstack.drill.end_layer = BoardLayer.BL_B_Cu

    @property
    def padstack(self) -> PadStack:
        return PadStack(proto_ref=self._proto.pad_stack)

    @property
    def diameter(self) -> int:
        """A helper property to get or set the diameter of the via on all copper layers.

        Warning: only makes sense if the via's padstack mode is PST_NORMAL.  This will return the
        pad diameter on the front copper layer otherwise.  Setting this property will set the
        padstack mode to PST_NORMAL as a side-effect.

        To get or set the diameter for other padstack types, use the padstack property directly.

        .. versionadded:: 0.3.0 with KiCad 9.0.1"""
        if len(self.padstack.copper_layers) == 0:
            raise ValueError("Unexpected empty padstack for via!")

        return self.padstack.copper_layers[0].size.x

    @diameter.setter
    def diameter(self, diameter: int):
        self.padstack.type = PST_NORMAL
        self.padstack.copper_layers[0].size = Vector2.from_xy(diameter, diameter)

    @property
    def drill_diameter(self) -> int:
        """The diameter of the via's drill (KiCad only supports circular drills in vias)"""
        return self.padstack.drill.diameter.x

    @drill_diameter.setter
    def drill_diameter(self, diameter: int):
        self.padstack.drill.diameter = Vector2.from_xy(diameter, diameter)


class FootprintAttributes(Wrapper):
    """The built-in attributes that a Footprint or FootprintInstance may have"""

    def __init__(
        self,
        proto: Optional[board_types_pb2.FootprintAttributes] = None,
        proto_ref: Optional[board_types_pb2.FootprintAttributes] = None,
    ):
        self._proto = (
            proto_ref
            if proto_ref is not None
            else board_types_pb2.FootprintAttributes()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def not_in_schematic(self) -> bool:
        return self._proto.not_in_schematic

    @not_in_schematic.setter
    def not_in_schematic(self, not_in_schematic: bool):
        self._proto.not_in_schematic = not_in_schematic

    @property
    def exclude_from_bill_of_materials(self) -> bool:
        return self._proto.exclude_from_bill_of_materials

    @exclude_from_bill_of_materials.setter
    def exclude_from_bill_of_materials(self, exclude: bool):
        self._proto.exclude_from_bill_of_materials = exclude

    @property
    def exclude_from_position_files(self) -> bool:
        return self._proto.exclude_from_position_files

    @exclude_from_position_files.setter
    def exclude_from_position_files(self, exclude: bool):
        self._proto.exclude_from_position_files = exclude

    @property
    def do_not_populate(self) -> bool:
        return self._proto.do_not_populate

    @do_not_populate.setter
    def do_not_populate(self, do_not_populate: bool):
        self._proto.do_not_populate = do_not_populate

    @property
    def mounting_style(self) -> board_types_pb2.FootprintMountingStyle.ValueType:
        """
        The mounting style of the footprint (SMD, through-hole, or unspecified)

        .. versionadded:: 0.3.0 with KiCad 9.0.1
        """
        return self._proto.mounting_style

    @mounting_style.setter
    def mounting_style(self, style: board_types_pb2.FootprintMountingStyle.ValueType):
        self._proto.mounting_style = style

class Footprint3DModel(Wrapper):
    """Represents a 3D model associated with a footprint"""

    def __init__(self, proto: Optional[board_types_pb2.Footprint3DModel] = None,
                 proto_ref: Optional[board_types_pb2.Footprint3DModel] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Footprint3DModel()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return (
            f"Footprint3DModel(filename='{self.filename}', "
            f"visisble={self.visible}, opacity={self.opacity}, "
            f"rotation=({self.rotation.x}, {self.rotation.y}, {self.rotation.z}), "
            f"scale=({self.scale.x}, {self.scale.y}, {self.scale.z}))"
        )

    @property
    def filename(self) -> str:
        return self._proto.filename

    @filename.setter
    def filename(self, filename: str):
        self._proto.filename = filename

    @property
    def scale(self) -> Vector3D:
        return Vector3D(self._proto.scale)

    @scale.setter
    def scale(self, scale: Vector3D):
        self._proto.scale.CopyFrom(scale.proto)

    @property
    def rotation(self) -> Vector3D:
        return Vector3D(self._proto.rotation)

    @rotation.setter
    def rotation(self, rotation: Vector3D):
        self._proto.rotation.CopyFrom(rotation.proto)

    @property
    def offset(self) -> Vector3D:
        return Vector3D(self._proto.offset)

    @offset.setter
    def offset(self, offset: Vector3D):
        self._proto.offset.CopyFrom(offset.proto)

    @property
    def visible(self) -> bool:
        return self._proto.visible

    @visible.setter
    def visible(self, visible: bool):
        self._proto.visible = visible

    @property
    def opacity(self) -> float:
        return self._proto.opacity

    @opacity.setter
    def opacity(self, opacity: float):
        self._proto.opacity = opacity

class Footprint(Wrapper):
    """Represents the definition of a footprint (existing in a footprint library or on a board),
    which contains the child objects of the footprint (pads, text, etc).  Footprint definitions are
    contained by a FootprintInstance which represents a footprint placed on a board."""

    def __init__(
        self,
        proto: Optional[board_types_pb2.Footprint] = None,
        proto_ref: Optional[board_types_pb2.Footprint] = None,
    ):
        self._proto = (
            proto_ref if proto_ref is not None else board_types_pb2.Footprint()
        )

        self._unwrapped_items = [unwrap(item) for item in self._proto.items]

        if proto is not None:
            self._proto.CopyFrom(proto)

    def _pack(self):
        """Packs all items in the footprint into the proto"""
        del self._proto.items[:]
        for item in self._unwrapped_items:
            any = Any()
            any.Pack(item.proto)
            self._proto.items.append(any)

    def __repr__(self) -> str:
        return f"Footprint(id={self.id}, items={len(self.items)})"

    @property
    def id(self) -> LibraryIdentifier:
        return LibraryIdentifier(proto_ref=self._proto.id)

    @id.setter
    def id(self, attributes: LibraryIdentifier):
        self._proto.id.CopyFrom(attributes.proto)

    @property
    def items(self) -> Sequence[Wrapper]:
        return self._unwrapped_items

    @property
    def pads(self) -> Sequence[Pad]:
        """Returns all pads in the footprint"""
        return [item for item in self.items if isinstance(item, Pad)]

    @property
    def shapes(self) -> Sequence[BoardShape]:
        """Returns all graphic shapes in the footprint"""
        return [
            item
            for item in (
                to_concrete_board_shape(shape)
                for shape in [item for item in self.items if isinstance(item, BoardShape)]
            )
            if item is not None
        ]

    @property
    def texts(self) -> Sequence[Union[BoardText, BoardTextBox, Field]]:
        """Returns all fields and free text objects in the footprint library definition"""
        return [
            item
            for item in self.items
            if isinstance(item, BoardText)
            or isinstance(item, BoardTextBox)
            or isinstance(item, Field)
        ]

    @property
    def models(self) -> Sequence[Footprint3DModel]:
        """Returns all 3D models in the footprint

        .. versionadded:: 0.3.0"""
        return [item for item in self.items if isinstance(item, Footprint3DModel)]

    def add_item(self, item: Wrapper):
        any = Any()
        any.Pack(item.proto)
        self._proto.items.append(any)


class FootprintInstance(BoardItem):
    """Represents a footprint instance on a board"""

    def __init__(self, proto: Optional[board_types_pb2.FootprintInstance] = None):
        self._proto = board_types_pb2.FootprintInstance()

        if proto is not None:
            self._proto.CopyFrom(proto)

        self._definition = Footprint(proto_ref=self._proto.definition)

    @property
    def proto(self):
        self._definition._pack()
        #self._proto.definition.CopyFrom(self._definition.proto)
        return self.__dict__['_proto']

    def __repr__(self) -> str:
        return f"FootprintInstance(id={self.id}, pos={self.position}, layer={BoardLayer.Name(self.layer)})"

    @property
    def id(self) -> KIID:
        return self._proto.id

    @property
    def position(self) -> Vector2:
        return Vector2(self._proto.position)

    @position.setter
    def position(self, position: Vector2):
        """Changes the footprint position, which will also update the positions of all the
        contained items since KiCad footprint children are stored with absolute positions"""
        delta = position - self.position
        self._proto.position.CopyFrom(position.proto)

        for field in [
            self.reference_field,
            self.value_field,
            self.datasheet_field,
            self.description_field,
        ]:
            field.text.position += delta

        for item in self.definition.items:
            if isinstance(item, Field):
                item.text.position += delta
            elif isinstance(item, Pad) or isinstance(item, BoardText):
                item.position += delta
            elif isinstance(item, Zone):
                item.move(delta)
            elif isinstance(item, BoardShape):
                shape = to_concrete_board_shape(item)
                assert shape
                shape.move(delta)

    @property
    def orientation(self) -> Angle:
        return Angle(self._proto.orientation)

    @orientation.setter
    def orientation(self, orientation: Angle):
        orientation.normalize180()
        delta = orientation - self.orientation
        self._proto.orientation.CopyFrom(orientation.proto)

        for field in [
            self.reference_field,
            self.value_field,
            self.datasheet_field,
            self.description_field,
        ]:
            field.text.position = field.text.position.rotate(delta, self.position)
            field.text.attributes.angle += delta.degrees

        for item in self.definition.items:
            if isinstance(item, Field):
                item.text.position = item.text.position.rotate(delta, self.position)
                item.text.attributes.angle += delta.degrees
            elif isinstance(item, Pad):
                item.position = item.position.rotate(delta, self.position)
                item.padstack.angle += delta
            elif isinstance(item, BoardText):
                item.position = item.position.rotate(delta, self.position)
                item.attributes.angle += delta.degrees
            elif isinstance(item, Zone):
                item.rotate(delta, self.position)
            elif isinstance(item, BoardShape):
                shape = to_concrete_board_shape(item)
                assert shape
                shape.rotate(delta, self.position)

    @property
    def layer(self) -> BoardLayer.ValueType:
        """The layer on which the footprint is placed (BoardLayer.BL_F_Cu or BoardLayer.BL_B_Cu)"""
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def locked(self) -> bool:
        return self._proto.locked == LockedState.LS_LOCKED

    @locked.setter
    def locked(self, locked: bool):
        self._proto.locked = (
            LockedState.LS_LOCKED if locked else LockedState.LS_UNLOCKED
        )

    @property
    def definition(self) -> Footprint:
        return self._definition

    @property
    def reference_field(self) -> Field:
        return Field(proto_ref=self._proto.reference_field)

    @reference_field.setter
    def reference_field(self, field: Field):
        self._proto.reference_field.CopyFrom(field.proto)

    @property
    def value_field(self) -> Field:
        return Field(proto_ref=self._proto.value_field)

    @value_field.setter
    def value_field(self, field: Field):
        self._proto.value_field.CopyFrom(field.proto)

    @property
    def datasheet_field(self) -> Field:
        return Field(proto_ref=self._proto.datasheet_field)

    @datasheet_field.setter
    def datasheet_field(self, field: Field):
        self._proto.datasheet_field.CopyFrom(field.proto)

    @property
    def description_field(self) -> Field:
        return Field(proto_ref=self._proto.description_field)

    @description_field.setter
    def description_field(self, field: Field):
        self._proto.description_field.CopyFrom(field.proto)

    @property
    def attributes(self) -> FootprintAttributes:
        return FootprintAttributes(proto_ref=self._proto.attributes)

    @property
    def texts_and_fields(self) -> Sequence[Union[BoardText, BoardTextBox, Field]]:
        """Returns all fields and free text objects in the footprint"""
        return [
            item
            for item in self.definition.items
            if isinstance(item, BoardText)
            or isinstance(item, BoardTextBox)
            or isinstance(item, Field)
        ] + [
            self.reference_field,
            self.value_field,
            self.datasheet_field,
            self.description_field,
        ]

    @property
    def sheet_path(self) -> SheetPath:
        """
        The path to this footprint instance's corresponding symbol schematic sheet

        .. versionadded:: 0.4.0 with KiCad 9.0.3
        """
        return SheetPath(self._proto.symbol_path)


class ZoneFilledPolygons(Wrapper):
    """Represents the set of filled polygons of a zone on a single board layer"""

    def __init__(
        self,
        proto: Optional[board_types_pb2.ZoneFilledPolygons] = None,
        proto_ref: Optional[board_types_pb2.ZoneFilledPolygons] = None,
    ):
        self._proto = (
            proto_ref if proto_ref is not None else board_types_pb2.ZoneFilledPolygons()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def shapes(self) -> Sequence[PolygonWithHoles]:
        return [PolygonWithHoles(proto_ref=p) for p in self._proto.shapes.polygons]


class Zone(BoardItem):
    """Represents a copper, graphical, or rule area zone on a board"""

    def __init__(self, proto: Optional[board_types_pb2.Zone] = None,
                 proto_ref: Optional[board_types_pb2.Zone] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Zone()

        if proto is not None:
            self._proto.CopyFrom(proto)
        elif proto_ref is None:
            # Set reasonable defaults from KiCad ZONE_SETTINGS for convenience
            self.type = ZoneType.ZT_COPPER
            self.min_thickness = from_mm(0.25)
            self.min_island_area = 10 * from_mm(1) * from_mm(1)
            self.island_mode = IslandRemovalMode.IRM_ALWAYS
            self.border_style = ZoneBorderStyle.ZBS_DIAGONAL_EDGE
            self.border_hatch_pitch = from_mm(0.5)

    def __repr__(self) -> str:
        if self.type == ZoneType.ZT_COPPER:
            assert self.net is not None
            return f"Copper Zone(net={self.net.name}, layers={self.layers})"
        elif self.type == ZoneType.ZT_RULE_AREA:
            return f"Rule Area Zone(name={self.name}, layers={self.layers})"

        return f"Zone(name={self.name}, type={self.type}, layers={self.layers})"

    @property
    def type(self) -> ZoneType.ValueType:
        return self._proto.type

    @type.setter
    def type(self, type: ZoneType.ValueType):
        self._proto.type = type

    @property
    def layers(self) -> Sequence[BoardLayer.ValueType]:
        return self._proto.layers

    @layers.setter
    def layers(self, layers: Sequence[BoardLayer.ValueType]):
        del self._proto.layers[:]
        self._proto.layers.extend(layers)

    @property
    def outline(self) -> PolygonWithHoles:
        return PolygonWithHoles(proto_ref=self._proto.outline.polygons[0])

    @outline.setter
    def outline(self, outline: PolygonWithHoles):
        p = base_types_pb2.PolygonWithHoles()
        p.CopyFrom(outline.proto)
        del self._proto.outline.polygons[:]
        self._proto.outline.polygons.append(p)

    @property
    def name(self) -> str:
        return self._proto.name

    @name.setter
    def name(self, name: str):
        self._proto.name = name

    @property
    def priority(self) -> int:
        return self._proto.priority

    @priority.setter
    def priority(self, priority: int):
        self._proto.priority = priority

    @property
    def filled(self) -> bool:
        return self._proto.filled

    @property
    def locked(self) -> bool:
        return self._proto.locked == LockedState.LS_LOCKED

    @locked.setter
    def locked(self, locked: bool):
        self._proto.locked = (
            LockedState.LS_LOCKED if locked else LockedState.LS_UNLOCKED
        )

    @property
    def filled_polygons(self) -> dict[BoardLayer.ValueType, list[PolygonWithHoles]]:
        return {
            filled_polygon.layer: [
                PolygonWithHoles(proto_ref=p) for p in filled_polygon.shapes.polygons
            ]
            for filled_polygon in self._proto.filled_polygons
        }

    def is_rule_area(self) -> bool:
        return self.type == ZoneType.ZT_RULE_AREA

    @property
    def connection(self) -> Optional[ZoneConnectionSettings]:
        if self.is_rule_area():
            return None
        return ZoneConnectionSettings(proto_ref=self._proto.copper_settings.connection)

    @property
    def clearance(self) -> Optional[int]:
        """The override (local) clearance for this filled copper zone"""
        if self.is_rule_area():
            return None
        return self._proto.copper_settings.clearance.value_nm

    @clearance.setter
    def clearance(self, clearance: int):
        if self.is_rule_area():
            raise ValueError("clearance does not apply to rule areas")
        self._proto.copper_settings.clearance.value_nm = clearance

    @property
    def min_thickness(self) -> Optional[int]:
        if self.is_rule_area():
            return None
        return self._proto.copper_settings.min_thickness.value_nm

    @min_thickness.setter
    def min_thickness(self, thickness: int):
        if self.is_rule_area():
            raise ValueError("min thickness does not apply to rule areas")
        self._proto.copper_settings.min_thickness.value_nm = thickness

    @property
    def island_mode(self) -> Optional[IslandRemovalMode.ValueType]:
        if self.is_rule_area():
            return None
        return self._proto.copper_settings.island_mode

    @island_mode.setter
    def island_mode(self, mode: IslandRemovalMode.ValueType):
        if self.is_rule_area():
            raise ValueError("island removal mode does not apply to rule areas")
        self._proto.copper_settings.island_mode = mode

    @property
    def min_island_area(self) -> Optional[int]:
        if self.is_rule_area():
            return None
        return self._proto.copper_settings.min_island_area

    @min_island_area.setter
    def min_island_area(self, area: int):
        if self.is_rule_area():
            raise ValueError("minimum island area does not apply to rule areas")
        self._proto.copper_settings.min_island_area = area

    @property
    def fill_mode(self) -> Optional[ZoneFillMode.ValueType]:
        if self.is_rule_area():
            return None
        return self._proto.copper_settings.fill_mode

    @property
    def net(self) -> Optional[Net]:
        if self.is_rule_area():
            return None
        return Net(self._proto.copper_settings.net)

    @property
    def teardrop(self) -> Optional[board_types_pb2.TeardropSettings]:
        if self.is_rule_area():
            return None
        return self._proto.copper_settings.teardrop

    @property
    def border_style(self) -> ZoneBorderStyle.ValueType:
        return self._proto.border.style

    @border_style.setter
    def border_style(self, style: ZoneBorderStyle.ValueType):
        self._proto.border.style = style

    @property
    def border_hatch_pitch(self) -> int:
        return self._proto.border.pitch.value_nm

    @border_hatch_pitch.setter
    def border_hatch_pitch(self, value: int):
        self._proto.border.pitch.value_nm = value

    def bounding_box(self) -> Box2:
        return self.outline.bounding_box()

    def move(self, delta: Vector2):
        """Moves the zone by the given delta vector"""
        self.outline.move(delta)
        for polygon in self.filled_polygons.values():
            for shape in polygon:
                shape.move(delta)

    def rotate(self, angle: Angle, center: Vector2):
        """Rotates the zone by the given angle around the given center point"""
        self.outline.rotate(angle, center)

        for polygon in self.filled_polygons.values():
            for shape in polygon:
                shape.rotate(angle, center)

class Dimension(BoardItem):
    """Represents a dimension object on a board"""

    def __init__(self, proto: Optional[board_types_pb2.Dimension] = None,
                 proto_ref: Optional[board_types_pb2.Dimension] = None):
        self._proto = proto_ref if proto_ref is not None else board_types_pb2.Dimension()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def id(self) -> KIID:
        return self._proto.id

    @property
    def locked(self) -> bool:
        return self._proto.locked == LockedState.LS_LOCKED

    @locked.setter
    def locked(self, locked: bool):
        self._proto.locked = LockedState.LS_LOCKED if locked else LockedState.LS_UNLOCKED

    @property
    def layer(self) -> BoardLayer.ValueType:
        return self._proto.layer

    @layer.setter
    def layer(self, layer: BoardLayer.ValueType):
        self._proto.layer = layer

    @property
    def text(self) -> Text:
        return Text(proto_ref=self._proto.text)

    @text.setter
    def text(self, text: Text):
        self._proto.text.CopyFrom(text.proto)

    @property
    def override_text_enabled(self) -> bool:
        return self._proto.override_text_enabled

    @override_text_enabled.setter
    def override_text_enabled(self, enabled: bool):
        self._proto.override_text_enabled = enabled

    @property
    def override_text(self) -> str:
        return self._proto.override_text

    @override_text.setter
    def override_text(self, text: str):
        self._proto.override_text = text

    @property
    def prefix(self) -> str:
        return self._proto.prefix

    @prefix.setter
    def prefix(self, prefix: str):
        self._proto.prefix = prefix

    @property
    def suffix(self) -> str:
        return self._proto.suffix

    @suffix.setter
    def suffix(self, suffix: str):
        self._proto.suffix = suffix

    @property
    def unit(self) -> board_types_pb2.DimensionUnit.ValueType:
        return self._proto.unit

    @unit.setter
    def unit(self, unit: board_types_pb2.DimensionUnit.ValueType):
        self._proto.unit = unit

    @property
    def unit_format(self) -> board_types_pb2.DimensionUnitFormat.ValueType:
        return self._proto.unit_format

    @unit_format.setter
    def unit_format(self, format: board_types_pb2.DimensionUnitFormat.ValueType):
        self._proto.unit_format = format

    @property
    def arrow_direction(self) -> board_types_pb2.DimensionArrowDirection.ValueType:
        return self._proto.arrow_direction

    @arrow_direction.setter
    def arrow_direction(self, direction: board_types_pb2.DimensionArrowDirection.ValueType):
        self._proto.arrow_direction = direction

    @property
    def precision(self) -> board_types_pb2.DimensionPrecision.ValueType:
        return self._proto.precision

    @precision.setter
    def precision(self, precision: board_types_pb2.DimensionPrecision.ValueType):
        self._proto.precision = precision

    @property
    def suppress_trailing_zeroes(self) -> bool:
        return self._proto.suppress_trailing_zeroes

    @suppress_trailing_zeroes.setter
    def suppress_trailing_zeroes(self, suppress: bool):
        self._proto.suppress_trailing_zeroes = suppress

    @property
    def line_thickness(self) -> int:
        return self._proto.line_thickness.value_nm

    @line_thickness.setter
    def line_thickness(self, thickness: int):
        self._proto.line_thickness.value_nm = thickness

    @property
    def arrow_length(self) -> int:
        return self._proto.arrow_length.value_nm

    @arrow_length.setter
    def arrow_length(self, length: int):
        self._proto.arrow_length.value_nm = length

    @property
    def extension_offset(self) -> int:
        return self._proto.extension_offset.value_nm

    @extension_offset.setter
    def extension_offset(self, offset: int):
        self._proto.extension_offset.value_nm = offset

    @property
    def text_position(self) -> board_types_pb2.DimensionTextPosition.ValueType:
        return self._proto.text_position

    @text_position.setter
    def text_position(self, position: board_types_pb2.DimensionTextPosition.ValueType):
        self._proto.text_position = position

    @property
    def keep_text_aligned(self) -> bool:
        return self._proto.keep_text_aligned

    @keep_text_aligned.setter
    def keep_text_aligned(self, aligned: bool):
        self._proto.keep_text_aligned = aligned


class AlignedDimension(Dimension):
    def __init__(self, proto: Optional[board_types_pb2.Dimension] = None):
        self._proto = board_types_pb2.Dimension()

        if proto is not None:
            assert proto.WhichOneof("dimension_style") == "aligned"
            self._proto.CopyFrom(proto)
        else:
            self._proto.aligned.SetInParent()

    def __repr__(self) -> str:
        return (
            f"AlignedDimension(start={self.start}, end={self.end}, "
            f"height={self.height}, extension_height={self.extension_height})"
        )

    @property
    def start(self) -> Vector2:
        return Vector2(self._proto.aligned.start)

    @start.setter
    def start(self, start: Vector2):
        self._proto.aligned.start.CopyFrom(start.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._proto.aligned.end)

    @end.setter
    def end(self, end: Vector2):
        self._proto.aligned.end.CopyFrom(end.proto)

    @property
    def height(self) -> int:
        return self._proto.aligned.height.value_nm

    @height.setter
    def height(self, height: int):
        self._proto.aligned.height.value_nm = height

    @property
    def extension_height(self) -> int:
        return self._proto.aligned.extension_height.value_nm

    @extension_height.setter
    def extension_height(self, extension_height: int):
        self._proto.aligned.extension_height.value_nm = extension_height


class OrthogonalDimension(Dimension):
    def __init__(self, proto: Optional[board_types_pb2.Dimension] = None):
        self._proto = board_types_pb2.Dimension()

        if proto is not None:
            assert proto.WhichOneof("dimension_style") == "orthogonal"
            self._proto.CopyFrom(proto)
        else:
            self._proto.orthogonal.SetInParent()

    def __repr__(self) -> str:
        return f"OrthogonalDimension(start={self.start}, end={self.end}, alignment={self.alignment})"

    @property
    def start(self) -> Vector2:
        return Vector2(self._proto.orthogonal.start)

    @start.setter
    def start(self, start: Vector2):
        self._proto.orthogonal.start.CopyFrom(start.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._proto.orthogonal.end)

    @end.setter
    def end(self, end: Vector2):
        self._proto.orthogonal.end.CopyFrom(end.proto)

    @property
    def height(self) -> int:
        return self._proto.orthogonal.height.value_nm

    @height.setter
    def height(self, height: int):
        self._proto.orthogonal.height.value_nm = height

    @property
    def extension_height(self) -> int:
        return self._proto.orthogonal.extension_height.value_nm

    @extension_height.setter
    def extension_height(self, extension_height: int):
        self._proto.orthogonal.extension_height.value_nm = extension_height

    @property
    def alignment(self) -> base_types_pb2.AxisAlignment.ValueType:
        return self._proto.orthogonal.alignment

    @alignment.setter
    def alignment(self, alignment: base_types_pb2.AxisAlignment.ValueType):
        self._proto.orthogonal.alignment = alignment

class RadialDimension(Dimension):
    def __init__(self, proto: Optional[board_types_pb2.Dimension] = None):
        self._proto = board_types_pb2.Dimension()

        if proto is not None:
            assert proto.WhichOneof("dimension_style") == "radial"
            self._proto.CopyFrom(proto)
        else:
            self._proto.radial.SetInParent()

    def __repr__(self) -> str:
        return (
            f"RadialDimension(center={self.center}, radius_point={self.radius_point}, "
            f"leader_length={self.leader_length})"
        )

    @property
    def center(self) -> Vector2:
        return Vector2(self._proto.radial.center)

    @center.setter
    def center(self, center: Vector2):
        self._proto.radial.center.CopyFrom(center.proto)

    @property
    def radius_point(self) -> Vector2:
        return Vector2(self._proto.radial.radius_point)

    @radius_point.setter
    def radius_point(self, radius_point: Vector2):
        self._proto.radial.radius_point.CopyFrom(radius_point.proto)

    @property
    def leader_length(self) -> int:
        return self._proto.radial.leader_length.value_nm

    @leader_length.setter
    def leader_length(self, leader_length: int):
        self._proto.radial.leader_length.value_nm = leader_length


class LeaderDimension(Dimension):
    def __init__(self, proto: Optional[board_types_pb2.Dimension] = None):
        self._proto = board_types_pb2.Dimension()

        if proto is not None:
            assert proto.WhichOneof("dimension_style") == "leader"
            self._proto.CopyFrom(proto)
        else:
            self._proto.leader.SetInParent()

    def __repr__(self) -> str:
        return (
            f"LeaderDimension(start={self.start}, end={self.end}, "
            f"border_style={self.border_style})"
        )

    @property
    def start(self) -> Vector2:
        return Vector2(self._proto.leader.start)

    @start.setter
    def start(self, start: Vector2):
        self._proto.leader.start.CopyFrom(start.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._proto.leader.end)

    @end.setter
    def end(self, end: Vector2):
        self._proto.leader.end.CopyFrom(end.proto)

    @property
    def border_style(self) -> board_types_pb2.DimensionTextBorderStyle.ValueType:
        return self._proto.leader.border_style

    @border_style.setter
    def border_style(self, border_style: board_types_pb2.DimensionTextBorderStyle.ValueType):
        self._proto.leader.border_style = border_style


class CenterDimension(Dimension):
    def __init__(self, proto: Optional[board_types_pb2.Dimension] = None):
        self._proto = board_types_pb2.Dimension()

        if proto is not None:
            assert proto.WhichOneof("dimension_style") == "center"
            self._proto.CopyFrom(proto)
        else:
            self._proto.center.SetInParent()

    def __repr__(self) -> str:
        return f"CenterDimension(center={self.center}, end={self.end})"

    @property
    def center(self) -> Vector2:
        return Vector2(self._proto.center.center)

    @center.setter
    def center(self, center: Vector2):
        self._proto.center.center.CopyFrom(center.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._proto.center.end)

    @end.setter
    def end(self, end: Vector2):
        self._proto.center.end.CopyFrom(end.proto)


def to_concrete_dimension(dimension: Dimension) -> Optional[Dimension]:
    cls = {
        "aligned": AlignedDimension,
        "orthogonal": OrthogonalDimension,
        "radial": RadialDimension,
        "leader": LeaderDimension,
        "center": CenterDimension,
        None: None,
    }.get(dimension._proto.WhichOneof("dimension_style"), None)

    return cls(dimension._proto) if cls is not None else None


class BoardEditorAppearanceSettings(Wrapper):
    def __init__(
        self,
        proto: Optional[board_commands_pb2.BoardEditorAppearanceSettings] = None,
        proto_ref: Optional[board_commands_pb2.BoardEditorAppearanceSettings] = None,
    ):
        self._proto = (
            proto_ref
            if proto_ref is not None
            else board_commands_pb2.BoardEditorAppearanceSettings()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def inactive_layer_display(self) -> board_commands_pb2.InactiveLayerDisplayMode.ValueType:
        """How layers other than the active (selected) layer are displayed"""
        return self._proto.inactive_layer_display

    @inactive_layer_display.setter
    def inactive_layer_display(self, mode: board_commands_pb2.InactiveLayerDisplayMode.ValueType):
        self._proto.inactive_layer_display = mode

    @property
    def net_color_display(self) -> board_commands_pb2.NetColorDisplayMode.ValueType:
        """Whether to apply net and netclass colors to copper items and ratsnest lines"""
        return self._proto.net_color_display

    @net_color_display.setter
    def net_color_display(self, mode: board_commands_pb2.NetColorDisplayMode.ValueType):
        self._proto.net_color_display = mode

    @property
    def board_flip(self) -> board_commands_pb2.BoardFlipMode.ValueType:
        """Whether or not the board view is flipped (mirrored around the X axis)"""
        return self._proto.board_flip

    @board_flip.setter
    def board_flip(self, mode: board_commands_pb2.BoardFlipMode.ValueType):
        self._proto.board_flip = mode

    @property
    def ratsnest_display(self) -> board_commands_pb2.RatsnestDisplayMode.ValueType:
        """Whether or not ratsnest lines are drawn to hidden layers"""
        return self._proto.ratsnest_display

    @ratsnest_display.setter
    def ratsnest_display(self, mode: board_commands_pb2.RatsnestDisplayMode.ValueType):
        self._proto.ratsnest_display = mode


_proto_to_object: Dict[type[Message], type[Wrapper]] = {
    board_types_pb2.Arc: ArcTrack,
    board_types_pb2.BoardGraphicShape: BoardShape,
    board_types_pb2.BoardText: BoardText,
    board_types_pb2.BoardTextBox: BoardTextBox,
    board_types_pb2.Dimension: Dimension,
    board_types_pb2.Field: Field,
    board_types_pb2.Footprint3DModel: Footprint3DModel,
    board_types_pb2.FootprintInstance: FootprintInstance,
    board_types_pb2.Net: Net,
    board_types_pb2.Pad: Pad,
    board_types_pb2.Track: Track,
    board_types_pb2.Via: Via,
    board_types_pb2.Zone: Zone,
}


def unwrap(message: Any) -> Wrapper:
    concrete = unpack_any(message)
    wrapper = _proto_to_object.get(type(concrete), None)
    assert wrapper is not None
    return wrapper(proto=concrete)

```

# project.py
```project.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from typing import List, Union, overload

from kipy.client import KiCadClient
from kipy.project_types import NetClass, TextVariables
from kipy.proto.common.types import DocumentSpecifier, MapMergeMode, DocumentType
from kipy.proto.common.commands import project_commands_pb2
from kipy.proto.common.types import project_settings_pb2
from google.protobuf.empty_pb2 import Empty


class Project:
    def __init__(self, kicad: KiCadClient, document: DocumentSpecifier):
        self._kicad = kicad
        self._doc = document

        # TODO clean this up; no identifier for project right now
        if self._doc.type != DocumentType.DOCTYPE_PROJECT:
            self._doc.type = DocumentType.DOCTYPE_PROJECT

    @property
    def document(self) -> DocumentSpecifier:
        return self._doc

    @property
    def name(self) -> str:
        """Returns the name of the project"""
        return self._doc.project.name

    @property
    def path(self) -> str:
        return self._doc.project.path

    def get_net_classes(self) -> List[NetClass]:
        command = project_commands_pb2.GetNetClasses()
        response = self._kicad.send(command, project_commands_pb2.NetClassesResponse)
        return [NetClass(p) for p in response.net_classes]

    @overload
    def expand_text_variables(self, text: str) -> str:
        ...

    @overload
    def expand_text_variables(self, text: List[str]) -> List[str]:
        ...

    def expand_text_variables(self, text: Union[str, List[str]]) -> Union[str, List[str]]:
        command = project_commands_pb2.ExpandTextVariables()
        command.document.CopyFrom(self._doc)
        if isinstance(text, list):
            command.text.extend(text)
        else:
            command.text.append(text)
        response = self._kicad.send(command, project_commands_pb2.ExpandTextVariablesResponse)
        return (
            [text for text in response.text]
            if isinstance(text, list)
            else response.text[0]
            if len(response.text) > 0
            else ""
        )

    def get_text_variables(self) -> TextVariables:
        command = project_commands_pb2.GetTextVariables()
        command.document.CopyFrom(self._doc)
        response = self._kicad.send(command, project_settings_pb2.TextVariables)
        return TextVariables(response)

    def set_text_variables(
        self, variables: TextVariables, merge_mode: MapMergeMode.ValueType = MapMergeMode.MMM_MERGE
    ):
        command = project_commands_pb2.SetTextVariables()
        command.document.CopyFrom(self._doc)
        command.merge_mode = merge_mode
        command.variables.CopyFrom(variables.proto)
        self._kicad.send(command, Empty)

```

# wrapper.py
```wrapper.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from abc import ABC, abstractmethod
from typing import Optional

from google.protobuf.message import Message
from kipy.proto.common.types.base_types_pb2 import KIID

class Wrapper(ABC):
    def __init__(self, proto: Optional[Message] = None, proto_ref: Optional[Message] = None):
        pass

    @property
    def proto(self):
        self._pack()
        return self.__dict__['_proto']

    def _pack(self):
        """Used in some cases to ensure the internal proto state matches the Python
        class instance, for subclasses where the properties are not directly acting on
        the proto object.
        """
        pass

class Item(Wrapper):
    @property
    @abstractmethod
    def id(self) -> KIID:
        return KIID()

```

# common_types.py
```common_types.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from deprecated import deprecated
from typing import Optional, Sequence
from kipy.proto.common import types
from kipy.proto.common.types import base_types_pb2
from kipy.proto.common.types.base_types_pb2 import KIID
from kipy.geometry import (
    Box2,
    PolygonWithHoles,
    Vector2,
    arc_center,
    arc_radius,
    arc_start_angle,
    arc_end_angle,
)
from kipy.wrapper import Wrapper

# Re-exported protobuf enum types
from kipy.proto.common.types.enums_pb2 import (  # noqa
    HorizontalAlignment,
    VerticalAlignment,
)


class Commit:
    def __init__(self, id: KIID):
        self._id = id

    @property
    def id(self) -> KIID:
        return self._id


class SheetPath(Wrapper):
    """Represents the path to a unique sheet instance or symbol instance in a schematic"""

    def __init__(
        self,
        proto: Optional[types.SheetPath] = None,
        proto_ref: Optional[types.SheetPath] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.SheetPath()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def path(self) -> list[KIID]:
        return list(self._proto.path)

    @path.setter
    def path(self, path: list[KIID]):
        del self._proto.path[:]
        self._proto.path.extend(path)

    @property
    def path_human_readable(self) -> str:
        """The sheet path with human-readable sheet names.  May not be available in all contexts
        (for example, is not present in contexts where the SheetPath is sourced from a board
        object)"""
        return self._proto.path_human_readable

class Color(Wrapper):
    def __init__(
        self,
        proto: Optional[types.Color] = None,
        proto_ref: Optional[types.Color] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.Color()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def red(self) -> float:
        return self._proto.r

    @red.setter
    def red(self, red: float):
        self._proto.r = red

    @property
    def green(self) -> float:
        return self._proto.g

    @green.setter
    def green(self, green: float):
        self._proto.g = green

    @property
    def blue(self) -> float:
        return self._proto.b

    @blue.setter
    def blue(self, blue: float):
        self._proto.b = blue

    @property
    def alpha(self) -> float:
        return self._proto.a

    @alpha.setter
    def alpha(self, alpha: float):
        self._proto.a = alpha


class TextAttributes(Wrapper):
    def __init__(
        self,
        proto: Optional[types.TextAttributes] = None,
        proto_ref: Optional[types.TextAttributes] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.TextAttributes()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return (
            f"TextAttributes(font_name={self.font_name}, angle={self.angle}, "
            f"line_spacing={self.line_spacing}, italic={self.italic}, bold={self.bold}, "
            f"underlined={self.underlined}, mirrored={self.mirrored}, multiline={self.multiline}, "
            f"keep_upright={self.keep_upright}, size={self.size})"
        )

    @property
    @deprecated("This property will always return True in KiCad 9, and will be removed in KiCad 10")
    def visible(self) -> bool:
        """
        .. deprecated:: 0.3.0 removed in KiCad 9.0.1
        Text items are always visible as of 9.0.1, only Fields can be set to hidden
        """
        return self._proto.visible

    @visible.setter
    def visible(self, visible: bool):
        self._proto.visible = visible

    @property
    def font_name(self) -> str:
        return self._proto.font_name

    @font_name.setter
    def font_name(self, font_name: str):
        self._proto.font_name = font_name

    @property
    def angle(self) -> float:
        """The orientation of the text in degrees"""
        return self._proto.angle.value_degrees

    @angle.setter
    def angle(self, angle: float):
        self._proto.angle.value_degrees = angle

    @property
    def line_spacing(self) -> float:
        return self._proto.line_spacing

    @line_spacing.setter
    def line_spacing(self, line_spacing: float):
        self._proto.line_spacing = line_spacing

    @property
    def stroke_width(self) -> int:
        return self._proto.stroke_width.value_nm

    @stroke_width.setter
    def stroke_width(self, stroke_width: int):
        self._proto.stroke_width.value_nm = stroke_width

    @property
    def italic(self) -> bool:
        return self._proto.italic

    @italic.setter
    def italic(self, italic: bool):
        self._proto.italic = italic

    @property
    def bold(self) -> bool:
        return self._proto.bold

    @bold.setter
    def bold(self, bold: bool):
        self._proto.bold = bold

    @property
    def underlined(self) -> bool:
        return self._proto.underlined

    @underlined.setter
    def underlined(self, underlined: bool):
        self._proto.underlined = underlined

    @property
    def mirrored(self) -> bool:
        return self._proto.mirrored

    @mirrored.setter
    def mirrored(self, mirrored: bool):
        self._proto.mirrored = mirrored

    @property
    def multiline(self) -> bool:
        return self._proto.multiline

    @multiline.setter
    def multiline(self, multiline: bool):
        self._proto.multiline = multiline

    @property
    def keep_upright(self) -> bool:
        return self._proto.keep_upright

    @keep_upright.setter
    def keep_upright(self, keep_upright: bool):
        self._proto.keep_upright = keep_upright

    @property
    def size(self) -> Vector2:
        return Vector2(self._proto.size)

    @size.setter
    def size(self, size: Vector2):
        self._proto.size.CopyFrom(size.proto)

    @property
    def horizontal_alignment(self) -> types.HorizontalAlignment.ValueType:
        return self._proto.horizontal_alignment

    @horizontal_alignment.setter
    def horizontal_alignment(self, alignment: types.HorizontalAlignment.ValueType):
        self._proto.horizontal_alignment = alignment

    @property
    def vertical_alignment(self) -> types.VerticalAlignment.ValueType:
        return self._proto.vertical_alignment

    @vertical_alignment.setter
    def vertical_alignment(self, alignment: types.VerticalAlignment.ValueType):
        self._proto.vertical_alignment = alignment


class LibraryIdentifier(Wrapper):
    """A KiCad library identifier (LIB_ID), consisting of a library nickname and entry name"""

    def __init__(
        self,
        proto: Optional[types.LibraryIdentifier] = None,
        proto_ref: Optional[types.LibraryIdentifier] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.LibraryIdentifier()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def library(self) -> str:
        return self._proto.library_nickname

    @library.setter
    def library(self, library: str):
        self._proto.library_nickname = library

    @property
    def name(self) -> str:
        return self._proto.entry_name

    @name.setter
    def name(self, name: str):
        self._proto.entry_name = name

    def __str__(self) -> str:
        return f"{self.library}:{self.name}"


class StrokeAttributes(Wrapper):
    def __init__(
        self,
        proto: Optional[types.StrokeAttributes] = None,
        proto_ref: Optional[types.StrokeAttributes] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.StrokeAttributes()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def color(self) -> Color:
        """The stroke color.  Only supported in schematic graphics."""
        return Color(proto_ref=self._proto.color)

    @color.setter
    def color(self, color: Color):
        self._proto.color.CopyFrom(color.proto)

    @property
    def width(self) -> int:
        """The stroke line width in nanometers"""
        return self._proto.width.value_nm

    @width.setter
    def width(self, width: int):
        self._proto.width.value_nm = width

    @property
    def style(self) -> types.StrokeLineStyle.ValueType:
        return self._proto.style

    @style.setter
    def style(self, style: types.StrokeLineStyle.ValueType):
        self._proto.style = style


class GraphicFillAttributes(Wrapper):
    def __init__(
        self,
        proto: Optional[types.GraphicFillAttributes] = None,
        proto_ref: Optional[types.GraphicFillAttributes] = None,
    ):
        self._proto = (
            proto_ref if proto_ref is not None else types.GraphicFillAttributes()
        )

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def filled(self) -> bool:
        return self._proto.fill_type == types.GraphicFillType.GFT_FILLED

    @filled.setter
    def filled(self, fill: bool):
        self._proto.fill_type = (
            types.GraphicFillType.GFT_FILLED
            if fill
            else types.GraphicFillType.GFT_UNFILLED
        )

    @property
    def color(self) -> Color:
        """The fill color.  Only supported in schematic graphics."""
        return Color(proto_ref=self._proto.color)

    @color.setter
    def color(self, color: Color):
        self._proto.color.CopyFrom(color.proto)


class GraphicAttributes(Wrapper):
    def __init__(
        self,
        proto: Optional[types.GraphicAttributes] = None,
        proto_ref: Optional[types.GraphicAttributes] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.GraphicAttributes()

        if proto is not None:
            self._proto.CopyFrom(proto)

        self._stroke = StrokeAttributes(proto_ref=self._proto.stroke)
        self._fill = GraphicFillAttributes(proto_ref=self._proto.fill)

    @property
    def stroke(self) -> StrokeAttributes:
        return self._stroke

    @property
    def fill(self) -> GraphicFillAttributes:
        return self._fill


class Text(Wrapper):
    """Common text properties (wrapper for KiCad's EDA_TEXT) shared between board and schematic"""

    def __init__(
        self, proto: Optional[types.Text] = None, proto_ref: Optional[types.Text] = None
    ):
        self._proto = proto_ref if proto_ref is not None else types.Text()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def position(self) -> Vector2:
        return Vector2(self._proto.position)

    @position.setter
    def position(self, pos: Vector2):
        self._proto.position.CopyFrom(pos.proto)

    @property
    def value(self) -> str:
        return self._proto.text

    @value.setter
    def value(self, text: str):
        self._proto.text = text

    @property
    def attributes(self) -> TextAttributes:
        return TextAttributes(proto_ref=self._proto.attributes)

    @attributes.setter
    def attributes(self, attributes: TextAttributes):
        self._proto.attributes.CopyFrom(attributes.proto)


class TextBox(Wrapper):
    def __init__(
        self,
        proto: Optional[types.TextBox] = None,
        proto_ref: Optional[types.TextBox] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.TextBox()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def top_left(self) -> Vector2:
        return Vector2(self._proto.top_left)

    @top_left.setter
    def top_left(self, pos: Vector2):
        self._proto.top_left.CopyFrom(pos.proto)

    @property
    def bottom_right(self) -> Vector2:
        return Vector2(self._proto.bottom_right)

    @bottom_right.setter
    def bottom_right(self, pos: Vector2):
        self._proto.bottom_right.CopyFrom(pos.proto)

    @property
    def attributes(self) -> TextAttributes:
        return TextAttributes(proto_ref=self._proto.attributes)

    @attributes.setter
    def attributes(self, attributes: TextAttributes):
        self._proto.attributes.CopyFrom(attributes.proto)

    @property
    def value(self) -> str:
        return self._proto.text

    @value.setter
    def value(self, text: str):
        self._proto.text = text

    @property
    def size(self) -> Vector2:
        return self.bottom_right - self.top_left

    @size.setter
    def size(self, size: Vector2):
        new_br = self.top_left + size
        self._proto.bottom_right.CopyFrom(new_br.proto)


class GraphicShape(Wrapper):
    """Represents an abstract graphic shape (not a board or schematic item)"""

    def __init__(self, proto: Optional[base_types_pb2.GraphicShape] = None):
        self._graphic_proto = base_types_pb2.GraphicShape()

        if proto is not None:
            self._graphic_proto.CopyFrom(proto)

    @property
    def attributes(self) -> GraphicAttributes:
        return GraphicAttributes(proto_ref=self._graphic_proto.attributes)

    @attributes.setter
    def attributes(self, attributes: GraphicAttributes):
        self._graphic_proto.attributes.CopyFrom(attributes.proto)

    def bounding_box(self) -> Box2:
        raise NotImplementedError(
            f"bounding_box() not implemented for {type(self).__name__}"
        )


class Segment(GraphicShape):
    """Represents a base graphic segment (not a board or schematic item)"""

    def __init__(self, proto: Optional[base_types_pb2.GraphicShape] = None,
                 proto_ref: Optional[base_types_pb2.GraphicShape] = None):
        self._graphic_proto = proto_ref if proto_ref is not None else base_types_pb2.GraphicShape()

        if proto is not None:
            self._graphic_proto.CopyFrom(proto)

        assert self._graphic_proto.WhichOneof("geometry") == "segment"

    @property
    def start(self) -> Vector2:
        return Vector2(self._graphic_proto.segment.start)

    @start.setter
    def start(self, point: Vector2):
        self._graphic_proto.segment.start.CopyFrom(point.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._graphic_proto.segment.end)

    @end.setter
    def end(self, point: Vector2):
        self._graphic_proto.segment.end.CopyFrom(point.proto)

    def bounding_box(self) -> Box2:
        """Calculates the bounding box of the segment"""
        box = Box2()
        box.merge(self.start)
        box.merge(self.end)
        return box


class Arc(GraphicShape):
    """Represents a generic graphical arc (not a board or schematic item)"""

    def __init__(self, proto: Optional[base_types_pb2.GraphicShape] = None,
                 proto_ref: Optional[base_types_pb2.GraphicShape] = None):
        self._graphic_proto = proto_ref if proto_ref is not None else base_types_pb2.GraphicShape()

        if proto is not None:
            self._graphic_proto.CopyFrom(proto)

        assert self._graphic_proto.WhichOneof("geometry") == "arc"

    @property
    def start(self) -> Vector2:
        return Vector2(self._graphic_proto.arc.start)

    @start.setter
    def start(self, point: Vector2):
        self._graphic_proto.arc.start.CopyFrom(point.proto)

    @property
    def mid(self) -> Vector2:
        return Vector2(self._graphic_proto.arc.mid)

    @mid.setter
    def mid(self, point: Vector2):
        self._graphic_proto.arc.mid.CopyFrom(point.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._graphic_proto.arc.end)

    @end.setter
    def end(self, point: Vector2):
        self._graphic_proto.arc.end.CopyFrom(point.proto)

    def center(self) -> Optional[Vector2]:
        """
        Calculates the center of the arc.  Uses a different algorithm than KiCad so may have
        slightly different results.  The KiCad API preserves the start, middle, and end points of
        the arc, so any other properties such as the center point and angles must be calculated

        :return: The center of the arc, or None if the arc is degenerate
        """
        # TODO we may want to add an API call to get KiCad to calculate this for us,
        # for situations where matching KiCad's behavior exactly is important
        return arc_center(self.start, self.mid, self.end)

    def radius(self) -> float:
        """
        Calculates the radius of the arc.  Uses a different algorithm than KiCad so may have
        slightly different results.  The KiCad API preserves the start, middle, and end points of
        the arc, so any other properties such as the center point and angles must be calculated

        :return: The radius of the arc, or 0 if the arc is degenerate
        """
        # TODO we may want to add an API call to get KiCad to calculate this for us,
        # for situations where matching KiCad's behavior exactly is important
        return arc_radius(self.start, self.mid, self.end)

    def start_angle(self) -> Optional[float]:
        return arc_start_angle(self.start, self.mid, self.end)

    def end_angle(self) -> Optional[float]:
        return arc_end_angle(self.start, self.mid, self.end)

    def bounding_box(self) -> Box2:
        box = Box2()
        box.merge(self.start)
        box.merge(self.end)
        box.merge(self.mid)
        return box


class Circle(GraphicShape):
    """Represents a graphic circle (not a board or schematic item)"""

    def __init__(self, proto: Optional[base_types_pb2.GraphicShape] = None,
                 proto_ref: Optional[base_types_pb2.GraphicShape] = None):
        self._graphic_proto = proto_ref if proto_ref is not None else base_types_pb2.GraphicShape()

        if proto is not None:
            self._graphic_proto.CopyFrom(proto)

        assert self._graphic_proto.WhichOneof("geometry") == "circle"

    @property
    def center(self) -> Vector2:
        return Vector2(self._graphic_proto.circle.center)

    @center.setter
    def center(self, point: Vector2):
        self._graphic_proto.circle.center.CopyFrom(point.proto)

    @property
    def radius_point(self) -> Vector2:
        return Vector2(self._graphic_proto.circle.radius_point)

    @radius_point.setter
    def radius_point(self, radius_point: Vector2):
        self._graphic_proto.circle.radius_point.CopyFrom(radius_point.proto)

    def radius(self) -> float:
        """Calculates the radius of the circle"""
        return (self.radius_point - self.center).length()

    def bounding_box(self) -> Box2:
        """Calculates the bounding box of the circle"""
        box = Box2()
        box.merge(self.center)
        box.inflate(int(self.radius() + 0.5))
        return box


class Rectangle(GraphicShape):
    """Represents a graphic rectangle (not a board or schematic item)"""

    def __init__(self, proto: Optional[base_types_pb2.GraphicShape] = None,
                 proto_ref: Optional[base_types_pb2.GraphicShape] = None):
        self._graphic_proto = proto_ref if proto_ref is not None else base_types_pb2.GraphicShape()

        if proto is not None:
            self._graphic_proto.CopyFrom(proto)

        assert self._graphic_proto.WhichOneof("geometry") == "rectangle"

    @property
    def top_left(self) -> Vector2:
        return Vector2(self._graphic_proto.rectangle.top_left)

    @top_left.setter
    def top_left(self, point: Vector2):
        self._graphic_proto.rectangle.top_left.CopyFrom(point.proto)

    @property
    def bottom_right(self) -> Vector2:
        return Vector2(self._graphic_proto.rectangle.bottom_right)

    @bottom_right.setter
    def bottom_right(self, point: Vector2):
        self._graphic_proto.rectangle.bottom_right.CopyFrom(point.proto)

    def bounding_box(self) -> Box2:
        """Calculates the bounding box of the rectangle"""
        return Box2.from_pos_size(self.top_left, self.bottom_right - self.top_left)


class Polygon(GraphicShape):
    """Represents a graphic polygon (not a board or schematic item)"""

    def __init__(self, proto: Optional[base_types_pb2.GraphicShape] = None,
                 proto_ref: Optional[base_types_pb2.GraphicShape] = None):
        self._graphic_proto = proto_ref if proto_ref is not None else base_types_pb2.GraphicShape()

        if proto is not None:
            self._graphic_proto.CopyFrom(proto)

        assert self._graphic_proto.WhichOneof("geometry") == "polygon"
        self._polygons = [
            PolygonWithHoles(proto_ref=p) for p in self._graphic_proto.polygon.polygons
        ]

    def _pack(self):
        self._graphic_proto.polygon.ClearField('polygons')
        self._graphic_proto.polygon.polygons.extend([
            polygon.proto for polygon in self._polygons
        ])

    @property
    def polygons(self) -> list[PolygonWithHoles]:
        return self._polygons

    def bounding_box(self) -> Box2:
        """Calculates the bounding box of the polygon"""
        box = None
        for polygon in self.polygons:
            if box is None:
                box = polygon.bounding_box()
            else:
                box.merge(polygon.bounding_box())
        return box if box is not None else Box2()


class Bezier(GraphicShape):
    """Represents a graphic bezier curve (not a board or schematic item)"""

    def __init__(self, proto: Optional[base_types_pb2.GraphicShape] = None,
                 proto_ref: Optional[base_types_pb2.GraphicShape] = None):
        self._graphic_proto = proto_ref if proto_ref is not None else base_types_pb2.GraphicShape()

        if proto is not None:
            self._graphic_proto.CopyFrom(proto)

        assert self._graphic_proto.WhichOneof("geometry") == "bezier"

    @property
    def start(self) -> Vector2:
        return Vector2(self._graphic_proto.bezier.start)

    @start.setter
    def start(self, point: Vector2):
        self._graphic_proto.bezier.start.CopyFrom(point.proto)

    @property
    def control1(self) -> Vector2:
        return Vector2(self._graphic_proto.bezier.control1)

    @control1.setter
    def control1(self, point: Vector2):
        self._graphic_proto.bezier.control1.CopyFrom(point.proto)

    @property
    def control2(self) -> Vector2:
        return Vector2(self._graphic_proto.bezier.control2)

    @control2.setter
    def control2(self, point: Vector2):
        self._graphic_proto.bezier.control2.CopyFrom(point.proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._graphic_proto.bezier.end)

    @end.setter
    def end(self, point: Vector2):
        self._graphic_proto.bezier.end.CopyFrom(point.proto)

    def bounding_box(self) -> Box2:
        # TODO: maybe bring in a library for Bezier curve math so we can generate an
        # bounding box from the curve approximation like KiCad does?
        raise NotImplementedError()


def to_concrete_shape(shape: GraphicShape) -> Optional[GraphicShape]:
    cls = {
        "segment": Segment,
        "arc": Arc,
        "circle": Circle,
        "rectangle": Rectangle,
        "polygon": Polygon,
        "bezier": Bezier,
        None: None,
    }.get(shape._graphic_proto.WhichOneof("geometry"), None)

    return cls(shape._graphic_proto) if cls is not None else None


class CompoundShape(Wrapper):
    """Represents a compound shape (a collection of other shapes)"""

    def __init__(self, proto: Optional[base_types_pb2.CompoundShape] = None):
        self._proto = base_types_pb2.CompoundShape()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def shapes(self) -> Sequence[GraphicShape]:
        return [
            shape
            for shape in (
                to_concrete_shape(GraphicShape(subshape))
                for subshape in self._proto.shapes
            )
            if shape is not None
        ]

    def __iter__(self):
        return iter(self.shapes)

    def __len__(self):
        return len(self._proto.shapes)

    def __getitem__(self, index):
        return self.shapes[index]

    def __setitem__(self, index, shape: GraphicShape):
        self._proto.shapes[index].CopyFrom(shape._graphic_proto)

    def __delitem__(self, index):
        del self._proto.shapes[index]

    def append(self, shape: GraphicShape):
        new_shape = self._proto.shapes.add()
        new_shape.CopyFrom(shape.proto)


class TitleBlockInfo(Wrapper):
    def __init__(
        self,
        proto: Optional[types.TitleBlockInfo] = None,
        proto_ref: Optional[types.TitleBlockInfo] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.TitleBlockInfo()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @property
    def title(self) -> str:
        return self._proto.title

    @title.setter
    def title(self, title: str):
        self._proto.title = title

    @property
    def date(self) -> str:
        return self._proto.date

    @date.setter
    def date(self, date: str):
        self._proto.date = date

    @property
    def revision(self) -> str:
        return self._proto.revision

    @revision.setter
    def revision(self, revision: str):
        self._proto.revision = revision

    @property
    def company(self) -> str:
        return self._proto.company

    @company.setter
    def company(self, company: str):
        self._proto.company = company

    @property
    def comments(self) -> dict[int, str]:
        return {
            1: self._proto.comment1,
            2: self._proto.comment2,
            3: self._proto.comment3,
            4: self._proto.comment4,
            5: self._proto.comment5,
            6: self._proto.comment6,
            7: self._proto.comment7,
            8: self._proto.comment8,
            9: self._proto.comment9,
        }

    @comments.setter
    def comments(self, comments: dict[int, str]):
        if 1 in comments:
            self._proto.comment1 = comments[1]
        if 2 in comments:
            self._proto.comment2 = comments[2]
        if 3 in comments:
            self._proto.comment3 = comments[3]
        if 4 in comments:
            self._proto.comment4 = comments[4]
        if 5 in comments:
            self._proto.comment5 = comments[5]
        if 6 in comments:
            self._proto.comment6 = comments[6]
        if 7 in comments:
            self._proto.comment7 = comments[7]
        if 8 in comments:
            self._proto.comment8 = comments[8]
        if 9 in comments:
            self._proto.comment9 = comments[9]

```

# project_types.py
```project_types.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from typing import Optional

from kipy.common_types import Color
from kipy.proto.common.types import project_settings_pb2
from kipy.wrapper import Wrapper


class NetClass(Wrapper):
    def __init__(self, proto: project_settings_pb2.NetClass = project_settings_pb2.NetClass()):
        self._proto = proto
        self.proto.type = project_settings_pb2.NetClassType.NCT_EXPLICIT

    def __repr__(self) -> str:
        return (
            f"NetClass(name={self.name!r}, priority={self.priority!r}, clearance={self.clearance!r}, "
            f"track_width={self.track_width!r}, diff_pair_track_width={self.diff_pair_track_width!r}, "
            f"diff_pair_gap={self.diff_pair_gap!r}, diff_pair_via_gap={self.diff_pair_via_gap!r}, "
            f"via_diameter={self.via_diameter!r}, via_drill={self.via_drill!r}, "
            f"microvia_diameter={self.microvia_diameter!r}, microvia_drill={self.microvia_drill!r}, "
            f"board_color={self.board_color!r}, wire_width={self.wire_width!r}, "
            f"bus_width={self.bus_width!r}, schematic_color={self.schematic_color!r})"
        )

    @property
    def name(self) -> str:
        return self._proto.name

    @property
    def priority(self) -> int:
        return self._proto.priority

    @priority.setter
    def priority(self, priority: int):
        self._proto.priority = priority

    @property
    def type(self) -> project_settings_pb2.NetClassType.ValueType:
        """The type (explicit or implicit) of the net class.  This is a read-only property;
        net classes created through the API must always be explicit."""
        return self._proto.type

    @property
    def constituents(self) -> Optional[list[str]]:
        if self.type == project_settings_pb2.NetClassType.NCT_EXPLICIT:
            return None
        return list(self._proto.constituents)

    @property
    def clearance(self) -> Optional[int]:
        if self._proto.HasField("board") and self._proto.board.HasField("clearance"):
            return self._proto.board.clearance.value_nm
        return None

    @clearance.setter
    def clearance(self, clearance: Optional[int]):
        if clearance is None:
            self._proto.board.ClearField("clearance")
        else:
            self._proto.board.clearance.value_nm = clearance

    @property
    def track_width(self) -> Optional[int]:
        if self._proto.HasField("board") and self._proto.board.HasField("track_width"):
            return self._proto.board.track_width.value_nm
        return None

    @track_width.setter
    def track_width(self, width: Optional[int]):
        if width is None:
            self._proto.board.ClearField("track_width")
        else:
            self._proto.board.track_width.value_nm = width

    @property
    def diff_pair_track_width(self) -> Optional[int]:
        if self._proto.HasField("board") and self._proto.board.HasField("diff_pair_track_width"):
            return self._proto.board.diff_pair_track_width.value_nm
        return None

    @diff_pair_track_width.setter
    def diff_pair_track_width(self, width: Optional[int]):
        if width is None:
            self._proto.board.ClearField("diff_pair_track_width")
        else:
            self._proto.board.diff_pair_track_width.value_nm = width

    @property
    def diff_pair_gap(self) -> Optional[int]:
        if self._proto.HasField("board") and self._proto.board.HasField("diff_pair_gap"):
            return self._proto.board.diff_pair_gap.value_nm
        return None

    @diff_pair_gap.setter
    def diff_pair_gap(self, gap: Optional[int]):
        if gap is None:
            self._proto.board.ClearField("diff_pair_gap")
        else:
            self._proto.board.diff_pair_gap.value_nm = gap

    @property
    def diff_pair_via_gap(self) -> Optional[int]:
        if self._proto.HasField("board") and self._proto.board.HasField("diff_pair_via_gap"):
            return self._proto.board.diff_pair_via_gap.value_nm
        return None

    @diff_pair_via_gap.setter
    def diff_pair_via_gap(self, gap: Optional[int]):
        if gap is None:
            self._proto.board.ClearField("diff_pair_via_gap")
        else:
            self._proto.board.diff_pair_via_gap.value_nm = gap

    @property
    def via_diameter(self) -> Optional[int]:
        if (self._proto.board.HasField("via_stack")
            and len(self._proto.board.via_stack.copper_layers) > 0
        ):
            return self._proto.board.via_stack.copper_layers[0].size.x_nm
        return None

    @via_diameter.setter
    def via_diameter(self, diameter: Optional[int]):
        if diameter is None:
            self._proto.board.via_stack.ClearField("copper_layers")
        else:
            self._proto.board.via_stack.copper_layers[0].size.x_nm = diameter


    @property
    def via_drill(self) -> Optional[int]:
        if (self._proto.board.HasField("via_stack")
            and self._proto.board.via_stack.HasField("drill")
        ):
            return self._proto.board.via_stack.drill.diameter.x_nm
        return None

    @via_drill.setter
    def via_drill(self, diameter: Optional[int]):
        if diameter is None:
            self._proto.board.via_stack.ClearField("drill")
        else:
            self._proto.board.via_stack.drill.diameter.x_nm = diameter

    @property
    def microvia_diameter(self) -> Optional[int]:
        if self._proto.board.HasField("microvia_stack"):
            return self._proto.board.microvia_stack.copper_layers[0].size.x_nm
        return None

    @microvia_diameter.setter
    def microvia_diameter(self, diameter: Optional[int]):
        if diameter is None:
            self._proto.board.ClearField("microvia_stack")
        else:
            self._proto.board.microvia_stack.copper_layers[0].size.x_nm = diameter

    @property
    def microvia_drill(self) -> Optional[int]:
        if (self._proto.board.HasField("microvia_stack")
            and self._proto.board.microvia_stack.HasField("drill")
        ):
            return self._proto.board.microvia_stack.drill.diameter.x_nm
        return None

    @microvia_drill.setter
    def microvia_drill(self, diameter: Optional[int]):
        if diameter is None:
            self._proto.board.microvia_stack.ClearField("drill")
        else:
            self._proto.board.microvia_stack.drill.diameter.x_nm = diameter

    @property
    def board_color(self) -> Optional[Color]:
        if self._proto.HasField("board") and self._proto.board.HasField("color"):
            return Color(self._proto.board.color)
        return None

    @board_color.setter
    def board_color(self, color: Optional[Color]):
        if color is None:
            self._proto.board.ClearField("color")
        else:
            self._proto.board.color.CopyFrom(color.proto)

    @property
    def wire_width(self) -> Optional[int]:
        if self._proto.HasField("schematic") and self._proto.schematic.HasField("wire_width"):
            return self._proto.schematic.wire_width.value_nm
        return None

    @wire_width.setter
    def wire_width(self, value: Optional[int]):
        if value is None:
            self._proto.schematic.ClearField("wire_width")
        else:
            self._proto.schematic.wire_width.value_nm = value

    @property
    def bus_width(self) -> Optional[int]:
        if self._proto.HasField("schematic") and self._proto.schematic.HasField("bus_width"):
            return self._proto.schematic.bus_width.value_nm
        return None

    @bus_width.setter
    def bus_width(self, value: Optional[int]):
        if value is None:
            self._proto.schematic.ClearField("bus_width")
        else:
            self._proto.schematic.bus_width.value_nm = value

    @property
    def schematic_color(self) -> Optional[Color]:
        if self._proto.HasField("schematic") and self._proto.schematic.HasField("color"):
            return Color(self._proto.schematic.color)
        return None

    @schematic_color.setter
    def schematic_color(self, color: Optional[Color]):
        if color is None:
            self._proto.schematic.ClearField("color")
        else:
            self._proto.schematic.color.CopyFrom(color.proto)

class TextVariables(Wrapper):
    def __init__(self, proto: project_settings_pb2.TextVariables = project_settings_pb2.TextVariables()):
        self._proto = proto

    @property
    def variables(self) -> dict:
        return dict(self._proto.variables)

    @variables.setter
    def variables(self, value: dict):
        self._proto.variables.clear()
        self._proto.variables.update(value)

    def __getitem__(self, key: str) -> str:
        return self._proto.variables[key]

    def __setitem__(self, key: str, value: str):
        self._proto.variables[key] = value

    def __delitem__(self, key: str):
        del self._proto.variables[key]

    def __contains__(self, key: str) -> bool:
        return key in self._proto.variables

    def __iter__(self):
        return iter(self._proto.variables)

    def __len__(self) -> int:
        return len(self._proto.variables)

    def keys(self):
        return self._proto.variables.keys()

    def values(self):
        return self._proto.variables.values()

    def items(self):
        return self._proto.variables.items()

    def __repr__(self) -> str:
        return f"TextVariables({self._proto.variables})"

```

# kicad.py
```kicad.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Classes for interacting with KiCad at a high level"""

import os
import platform
import random
import string
from tempfile import gettempdir
from typing import Optional, Sequence, Union
from google.protobuf.empty_pb2 import Empty

from kipy.board import Board
from kipy.client import KiCadClient, ApiError
from kipy.common_types import Text, TextBox, CompoundShape
from kipy.errors import FutureVersionError
from kipy.geometry import Box2
from kipy.project import Project
from kipy.proto.common import commands
from kipy.proto.common.types import base_types_pb2, DocumentType, DocumentSpecifier
from kipy.proto.common.commands import base_commands_pb2
from kipy.kicad_api_version import KICAD_API_VERSION


def _default_socket_path() -> str:
    path = os.environ.get('KICAD_API_SOCKET')
    if path is not None:
        return path
    return f'ipc://{gettempdir()}\\kicad\\api.sock' if platform.system() == 'Windows' else 'ipc:///tmp/kicad/api.sock'

def _random_client_name() -> str:
    return 'anonymous-'+''.join(random.choices(string.ascii_lowercase + string.digits, k=8))

def _default_kicad_token() -> str:
    token = os.environ.get('KICAD_API_TOKEN')
    if token is not None:
        return token
    return ""

class KiCadVersion:
    def __init__(self, major: int, minor: int, patch: int, full_version: str):
        self.major = major
        self.minor = minor
        self.patch = patch
        self.full_version = full_version

    @staticmethod
    def from_proto(proto: base_types_pb2.KiCadVersion) -> 'KiCadVersion':
        return KiCadVersion(proto.major, proto.minor, proto.patch, proto.full_version)

    @staticmethod
    def from_git_describe(describe: str) -> 'KiCadVersion':
        parts = describe.split('-')
        version_part = parts[0]
        major, minor, patch = map(int, version_part.split('.'))

        if len(parts) > 1:
            additional_info = '-'.join(parts[1:])
            return KiCadVersion(major, minor, patch, f"{version_part}-{additional_info}")

        return KiCadVersion(major, minor, patch, f"{version_part}")

    def __repr__(self):
        return f"{self.major}.{self.minor}.{self.patch} ({self.full_version})"

    def __eq__(self, other):
        if not isinstance(other, KiCadVersion):
            return NotImplemented

        return (
            (self.major, self.minor, self.patch) == (other.major, other.minor, other.patch)
            )

    def __lt__(self, other):
        if not isinstance(other, KiCadVersion):
            return NotImplemented
        return (self.major, self.minor, self.patch) < (other.major, other.minor, other.patch)

    def __le__(self, other):
        return self == other or self < other

    def __gt__(self, other):
        return not self <= other

    def __ge__(self, other):
        return not self < other

class KiCad:
    def __init__(self, socket_path: Optional[str]=None,
                 client_name: Optional[str]=None,
                 kicad_token: Optional[str]=None,
                 timeout_ms: int=2000):
        """Creates a connection to a running KiCad instance

        :param socket_path: The path to the IPC API socket (leave default to read from the
            KICAD_API_SOCKET environment variable, which will be set automatically by KiCad when
            launching API plugins, or to use the default platform-dependent socket path if the
            environment variable is not set).
        :param client_name: A unique name identifying this plugin instance.  Leave default to
            generate a random client name.
        :param kicad_token: A token that can be provided to the client to uniquely identify a
            KiCad instance.  Leave default to read from the KICAD_API_TOKEN environment variable.
        :param timeout_ms: The maximum time to wait for a response from KiCad, in milliseconds
        """
        if socket_path is None:
            socket_path = _default_socket_path()
        if client_name is None:
            client_name = _random_client_name()
        if kicad_token is None:
            kicad_token = _default_kicad_token()
        self._client = KiCadClient(socket_path, client_name, kicad_token, timeout_ms)

    @staticmethod
    def from_client(client: KiCadClient):
        """Creates a KiCad object from an existing KiCad client"""
        k = KiCad.__new__(KiCad)
        k._client = client
        return k

    def get_version(self) -> KiCadVersion:
        """Returns the KiCad version as a string, including any package-specific info"""
        response = self._client.send(commands.GetVersion(), commands.GetVersionResponse)
        return KiCadVersion.from_proto(response.version)

    def get_api_version(self) -> KiCadVersion:
        """Returns the version of KiCad that this library was built against"""
        return KiCadVersion.from_git_describe(KICAD_API_VERSION)

    def check_version(self) -> bool:
        """Checks if the connected KiCad version matches the version this library was built against"""
        kicad_version = self.get_version()
        api_version = self.get_api_version()

        if kicad_version > api_version:
            raise FutureVersionError(
                f"Warning: Connected KiCad version ({kicad_version}) is newer than "
                f"the API version of kicad-python ({api_version})"
            )

        return True

    def ping(self):
        self._client.send(commands.Ping(), Empty)

    def get_kicad_binary_path(self, binary_name: str) -> str:
        """Returns the full path to the given KiCad binary

        :param binary_name: The short name of the binary, such as `kicad-cli` or `kicad-cli.exe`.
                            If on Windows, an `.exe` extension will be assumed if not present.
        :return: The full path to the binary
        """
        cmd = commands.GetKiCadBinaryPath()
        cmd.binary_name = binary_name
        return self._client.send(cmd, commands.PathResponse).path

    def get_plugin_settings_path(self, identifier: str) -> str:
        """Return a writeable path that a plugin can use for storing persistent data such as
        configuration files, etc.  This path may not yet exist; actual creation of the directory
        for a given plugin is up to the plugin itself.  Files in this path will not be modified if
        the plugin is uninstalled or upgraded.

        :param identifier: should be the full identifier of the plugin (e.g. org.kicad.myplugin)
        :return: a path, with local separators, that the plugin can use for storing settings
        """
        cmd = commands.GetPluginSettingsPath()
        cmd.identifier = identifier
        return self._client.send(cmd, commands.StringResponse).response

    def run_action(self, action: str):
        """Runs a KiCad tool action, if it is available

        WARNING: This is an unstable API and is not intended for use other
        than by API developers. KiCad does not guarantee the stability of
        action names, and running actions may have unintended side effects.
        :param action: the name of a KiCad TOOL_ACTION
        :return: a value from the KIAPI.COMMON.COMMANDS.RUN_ACTION_STATUS enum
        """
        return self._client.send(commands.RunAction(), commands.RunActionResponse)

    def get_open_documents(self, doc_type: DocumentType.ValueType) -> Sequence[DocumentSpecifier]:
        """Retrieves a list of open documents matching the given type"""
        command = commands.GetOpenDocuments()
        command.type = doc_type
        response = self._client.send(command, commands.GetOpenDocumentsResponse)
        return response.documents

    def get_project(self, document: DocumentSpecifier) -> Project:
        """Returns a Project object for the given document"""
        return Project(self._client, document)

    def get_board(self) -> Board:
        """Retrieves a reference to the PCB open in KiCad, if one exists"""
        docs = self.get_open_documents(DocumentType.DOCTYPE_PCB)
        if len(docs) == 0:
            raise ApiError("Expected to be able to retrieve at least one board")
        return Board(self._client, docs[0])

    # Utility functions

    def get_text_extents(self, text: Text) -> Box2:
        """Returns the bounding box of the given text object"""
        cmd = base_commands_pb2.GetTextExtents()
        cmd.text.CopyFrom(text.proto)
        reply = self._client.send(cmd, base_types_pb2.Box2)
        return Box2.from_proto(reply)

    def get_text_as_shapes(
        self, texts: Union[Text, TextBox, Sequence[Union[Text, TextBox]]]
    ) -> list[CompoundShape]:
        """Returns polygonal shapes representing the given text objects"""
        if isinstance(texts, Text) or isinstance(texts, TextBox):
            texts = [texts]

        cmd = base_commands_pb2.GetTextAsShapes()
        for t in texts:
            inner = base_commands_pb2.TextOrTextBox()
            if isinstance(t, Text):
                inner.text.CopyFrom(t.proto)
            else:
                inner.textbox.CopyFrom(t.proto)
            cmd.text.append(inner)

        reply = self._client.send(cmd, base_commands_pb2.GetTextAsShapesResponse)

        return [CompoundShape(entry.shapes) for entry in reply.text_with_shapes]

```

# geometry.py
```geometry.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import annotations

from typing import Optional, Union
import math
from kipy.proto.common import types
from kipy.util import from_mm
from kipy.wrapper import Wrapper

class Vector2(Wrapper):
    """Wraps a kiapi.common.types.Vector2, aka VECTOR2I"""
    def __init__(self, proto: Optional[types.Vector2] = None):
        self._proto = types.Vector2()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self):
        return f"Vector2({self.x}, {self.y})"

    @classmethod
    def from_xy(cls, x_nm: int, y_nm: int):
        """Initialize Vector2 with x and y values in nanometers"""
        proto = types.Vector2()
        proto.x_nm = x_nm
        proto.y_nm = y_nm
        return cls(proto)

    @classmethod
    def from_xy_mm(cls, x_mm: int, y_mm: int):
        """Initialize Vector2 with x and y values in mm

        .. versionadded:: 0.3.0"""
        proto = types.Vector2()
        proto.x_nm = from_mm(x_mm)
        proto.y_nm = from_mm(y_mm)
        return cls(proto)

    @property
    def x(self) -> int:
        return self._proto.x_nm

    @x.setter
    def x(self, val: int):
        self._proto.x_nm = val

    @property
    def y(self) -> int:
        return self._proto.y_nm

    @y.setter
    def y(self, val: int):
        self._proto.y_nm = val

    def __hash__(self):
        return hash((self.x, self.y))

    def __eq__(self, other):
        if isinstance(other, Vector2):
            return self.x == other.x and self.y == other.y
        return NotImplemented

    def __add__(self, other: Vector2) -> Vector2:
        r = Vector2(self._proto)
        r.x += other.x
        r.y += other.y
        return r

    def __sub__(self, other: Vector2) -> Vector2:
        r = Vector2(self._proto)
        r.x -= other.x
        r.y -= other.y
        return r

    def __neg__(self) -> Vector2:
        r = Vector2(self._proto)
        r.x = -r.x
        r.y = -r.y
        return r

    def __mul__(self, scalar: float) -> Vector2:
        r = Vector2(self._proto)
        r.x = int(float(r.x) * scalar)
        r.y = int(float(r.y) * scalar)
        return r

    def length(self) -> float:
        return math.sqrt(self.x * self.x + self.y * self.y)

    def angle(self) -> float:
        """Returns the angle (direction) of the vector in radians"""
        return math.atan2(self.y, self.x)

    def angle_degrees(self) -> float:
        """Returns the angle (direction) of the vector in degrees

        .. versionadded:: 0.3.0
        """
        return math.degrees(self.angle())

    def rotate(self, angle: Angle, center: Vector2) -> Vector2:
        """Rotates the vector in-place by an angle in degrees around a center point

        :param angle: The angle to rotate by
        :param center: The center point to rotate around
        :return: The rotated vector

        .. versionadded:: 0.4.0
        """
        pt_x = self.x - center.x
        pt_y = self.y - center.y
        rotation = normalize_angle_radians(angle.to_radians())

        sin_angle = math.sin(rotation)
        cos_angle = math.cos(rotation)

        self.x = int(pt_y * sin_angle + pt_x * cos_angle) + center.x
        self.y = int(pt_y * cos_angle - pt_x * sin_angle) + center.y

        return self

class Vector3D(Wrapper):
    """Wraps a kiapi.common.types.Vector3D"""
    def __init__(self, proto: Optional[types.Vector3D] = None):
        self._proto = types.Vector3D()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self):
        return f"Vector3D({self.x}, {self.y}, {self.z})"

    @classmethod
    def from_xyz(cls, x_nm: float, y_nm: float, z_nm: float):
        """Initialize Vector3D with x, y, and z values in nanometers"""
        proto = types.Vector3D()
        proto.x_nm = x_nm
        proto.y_nm = y_nm
        proto.z_nm = z_nm
        return cls(proto)

    @property
    def x(self) -> float:
        return self._proto.x_nm

    @x.setter
    def x(self, val: float):
        self._proto.x_nm = val

    @property
    def y(self) -> float:
        return self._proto.y_nm

    @y.setter
    def y(self, val: float):
        self._proto.y_nm = val

    @property
    def z(self) -> float:
        return self._proto.z_nm

    @z.setter
    def z(self, val: float):
        self._proto.z_nm = val

    def __hash__(self):
        return hash((self.x, self.y, self.z))

    def __eq__(self, other):
        if isinstance(other, Vector3D):
            return self.x == other.x and self.y == other.y and self.z == other.z
        return NotImplemented

    def __add__(self, other: Vector3D) -> Vector3D:
        r = Vector3D(self._proto)
        r.x += other.x
        r.y += other.y
        r.z += other.z
        return r

    def __sub__(self, other: Vector3D) -> Vector3D:
        r = Vector3D(self._proto)
        r.x -= other.x
        r.y -= other.y
        r.z -= other.z
        return r

    def __neg__(self) -> Vector3D:
        r = Vector3D(self._proto)
        r.x = -r.x
        r.y = -r.y
        r.z = -r.z
        return r

    def __mul__(self, scalar: float) -> Vector3D:
        r = Vector3D(self._proto)
        r.x = r.x * scalar
        r.y = r.y * scalar
        r.z = r.z * scalar
        return r

    def length(self) -> float:
        return math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)

class Box2:
    def __init__(
        self,
        pos_proto: Optional[types.Vector2] = None,
        size_proto: Optional[types.Vector2] = None,
    ):
        self._pos_proto = types.Vector2()
        self._size_proto = types.Vector2()

        if pos_proto is not None:
            self._pos_proto.CopyFrom(pos_proto)

        if size_proto is not None:
            self._size_proto.CopyFrom(size_proto)

    def __repr__(self):
        return f"Box2(pos={self.pos}, size={self.size})"

    @classmethod
    def from_xywh(cls, x_nm: int, y_nm: int, w_nm: int, h_nm: int):
        pos = Vector2.from_xy(x_nm, y_nm)
        size = Vector2.from_xy(w_nm, h_nm)
        return cls(pos._proto, size._proto)

    @classmethod
    def from_pos_size(cls, pos: Vector2, size: Vector2):
        return cls(pos._proto, size._proto)

    @classmethod
    def from_proto( cls, other: types.Box2):
        return cls(other.position, other.size)

    @property
    def pos(self) -> Vector2:
        return Vector2(self._pos_proto)

    @property
    def size(self) -> Vector2:
        return Vector2(self._size_proto)

    def move(self, delta: Vector2):
        self._pos_proto.x_nm += delta.x
        self._pos_proto.y_nm += delta.y

    def center(self) -> Vector2:
        center_x = self._pos_proto.x_nm + self._size_proto.x_nm // 2
        center_y = self._pos_proto.y_nm + self._size_proto.y_nm // 2
        return Vector2.from_xy(center_x, center_y)

    def merge(self, other: Union[Vector2, Box2]):
        if isinstance(other, Vector2):
            min_x = min(self.pos.x, other.x)
            min_y = min(self.pos.y, other.y)
            max_x = max(self.pos.x + self.size.x, other.x)
            max_y = max(self.pos.y + self.size.y, other.y)
        else:
            min_x = min(self.pos.x, other.pos.x)
            min_y = min(self.pos.y, other.pos.y)
            max_x = max(self.pos.x + self.size.x, other.pos.x + other.size.x)
            max_y = max(self.pos.y + self.size.y, other.pos.y + other.size.y)

        self._pos_proto.x_nm = min_x
        self._pos_proto.y_nm = min_y
        self._size_proto.x_nm = max_x - min_x
        self._size_proto.y_nm = max_y - min_y

    def inflate(self, amount: int):
        new_width = self.size.x + amount
        new_height = self.size.y + amount
        self._pos_proto.x_nm -= (new_width - self.size.x) // 2
        self._pos_proto.y_nm -= (new_height - self.size.y) // 2
        self._size_proto.x_nm = new_width
        self._size_proto.y_nm = new_height

class Angle(Wrapper):
    def __init__(self, proto: Optional[types.Angle] = None):
        self._proto = types.Angle()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self):
        return f"Angle({self.degrees})"

    @classmethod
    def from_degrees(cls, degrees: float):
        """Initialize Angle with a value in degrees"""
        proto = types.Angle()
        proto.value_degrees = degrees
        return cls(proto)

    @property
    def degrees(self) -> float:
        return self._proto.value_degrees

    @degrees.setter
    def degrees(self, val: float):
        self._proto.value_degrees = val

    def __eq__(self, other):
        if isinstance(other, Angle):
            return self.degrees == other.degrees
        return NotImplemented

    def __add__(self, other: Angle) -> Angle:
        return Angle.from_degrees(self.degrees + other.degrees)

    def __sub__(self, other: Angle) -> Angle:
        return Angle.from_degrees(self.degrees - other.degrees)

    def __neg__(self) -> Angle:
        return Angle.from_degrees(-self.degrees)

    def __mul__(self, scalar: float) -> Angle:
        return Angle.from_degrees(self.degrees * scalar)

    def to_radians(self) -> float:
        return math.radians(self.degrees)

    def normalize(self) -> Angle:
        """Normalizes the angle to fall within the range [0, 360)

        .. versionadded:: 0.4.0"""
        while self.degrees < 0.0:
            self.degrees += 360.0

        while self.degrees >= 360.0:
            self.degrees -= 360.0

        return self

    def normalize180(self) -> Angle:
        """Normalizes the angle to fall within the range [-180, 180)

        .. versionadded:: 0.4.0"""
        while self.degrees <= -180.0:
            self.degrees += 360.0

        while self.degrees > 180.0:
            self.degrees -= 360.0

        return self

class ArcStartMidEnd(Wrapper):
    def __init__(
        self,
        proto: Optional[types.ArcStartMidEnd] = None,
        proto_ref: Optional[types.ArcStartMidEnd] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.ArcStartMidEnd()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self):
        return f"ArcStartMidEnd(start={self.start}, mid={self.mid}, end={self.end})"

    @property
    def start(self) -> Vector2:
        return Vector2(self._proto.start)

    @start.setter
    def start(self, val: Vector2):
        self._proto.start.CopyFrom(val._proto)

    @property
    def mid(self) -> Vector2:
        return Vector2(self._proto.mid)

    @mid.setter
    def mid(self, val: Vector2):
        self._proto.mid.CopyFrom(val._proto)

    @property
    def end(self) -> Vector2:
        return Vector2(self._proto.end)

    @end.setter
    def end(self, val: Vector2):
        self._proto.end.CopyFrom(val._proto)

    def center(self) -> Optional[Vector2]:
        """
        Calculates the center of the arc.  Uses a different algorithm than KiCad so may have
        slightly different results.  The KiCad API preserves the start, middle, and end points of
        the arc, so any other properties such as the center point and angles must be calculated

        :return: The center of the arc, or None if the arc is degenerate
        """
        # TODO we may want to add an API call to get KiCad to calculate this for us,
        # for situations where matching KiCad's behavior exactly is important
        return arc_center(self.start, self.mid, self.end)

    def radius(self) -> float:
        """
        Calculates the radius of the arc.  Uses a different algorithm than KiCad so may have
        slightly different results.  The KiCad API preserves the start, middle, and end points of
        the arc, so any other properties such as the center point and angles must be calculated

        :return: The radius of the arc, or 0 if the arc is degenerate
        """
        # TODO we may want to add an API call to get KiCad to calculate this for us,
        # for situations where matching KiCad's behavior exactly is important
        return arc_radius(self.start, self.mid, self.end)

    def start_angle(self) -> Optional[float]:
        return arc_start_angle(self.start, self.mid, self.end)

    def end_angle(self) -> Optional[float]:
        return arc_end_angle(self.start, self.mid, self.end)

    def bounding_box(self) -> Box2:
        """Returns the bounding box of the arc -- not calculated by KiCad; may differ from KiCad's"""
        box = Box2()
        box.merge(self.start)
        box.merge(self.end)
        box.merge(self.mid)
        return box

class PolyLineNode(Wrapper):
    def __init__(
        self,
        proto: Optional[types.PolyLineNode] = None,
        proto_ref: Optional[types.PolyLineNode] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.PolyLineNode()

        if proto is not None:
            self._proto.CopyFrom(proto)

    @staticmethod
    def from_point(point: Vector2):
        n = PolyLineNode()
        n.point = point
        return n

    @staticmethod
    def from_xy(x: int, y: int):
        n = PolyLineNode()
        n.point = Vector2.from_xy(x, y)
        return n

    def __repr__(self):
        if self.has_point:
            return f"PolyLineNode(point={self.point})"
        elif self.has_arc:
            return f"PolyLineNode(arc={self.arc})"
        return "PolyLineNode()"

    @property
    def has_point(self) -> bool:
        return self._proto.HasField("point")

    @property
    def point(self) -> Vector2:
        return Vector2(self._proto.point)

    @point.setter
    def point(self, val: Vector2):
        self._proto.point.CopyFrom(val._proto)

    @property
    def has_arc(self) -> bool:
        return self._proto.HasField("arc")

    @property
    def arc(self) -> ArcStartMidEnd:
        return ArcStartMidEnd(self._proto.arc)

    @arc.setter
    def arc(self, val: ArcStartMidEnd):
        self._proto.arc.CopyFrom(val._proto)

class PolyLine(Wrapper):
    def __init__(
        self,
        proto: Optional[types.PolyLine] = None,
        proto_ref: Optional[types.PolyLine] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.PolyLine()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self):
        return f"PolyLine(nodes={self.nodes}, closed={self.closed})"

    @property
    def nodes(self) -> list[PolyLineNode]:
        return [PolyLineNode(proto_ref=node) for node in self._proto.nodes]

    @property
    def closed(self) -> bool:
        return self._proto.closed

    @closed.setter
    def closed(self, val: bool):
        self._proto.closed = val

    def __iter__(self):
        return iter(self.nodes)

    def __len__(self):
        return len(self.nodes)

    def __getitem__(self, index: int) -> PolyLineNode:
        return self.nodes[index]

    def __setitem__(self, index: int, value: PolyLineNode):
        self._proto.nodes[index].CopyFrom(value._proto)

    def append(self, node: PolyLineNode):
        self._proto.nodes.append(node._proto)

    def insert(self, index: int, node: PolyLineNode):
        self._proto.nodes.insert(index, node._proto)

    def remove(self, node: PolyLineNode):
        self._proto.nodes.remove(node._proto)

    def clear(self):
        self._proto.ClearField("nodes")

    def rotate(self, delta: Angle, center: Vector2):
        for node in self.nodes:
            if node.has_point:
                node.point = node.point.rotate(delta, center)
            elif node.has_arc:
                node.arc.start = node.arc.start.rotate(delta, center)
                node.arc.mid = node.arc.mid.rotate(delta, center)
                node.arc.end = node.arc.end.rotate(delta, center)

class PolygonWithHoles(Wrapper):
    def __init__(
        self,
        proto: Optional[types.PolygonWithHoles] = None,
        proto_ref: Optional[types.PolygonWithHoles] = None,
    ):
        self._proto = proto_ref if proto_ref is not None else types.PolygonWithHoles()

        if proto is not None:
            self._proto.CopyFrom(proto)

    def __repr__(self):
        return f"PolygonWithHoles(outline={self.outline}, holes={self.holes})"

    @property
    def outline(self) -> PolyLine:
        return PolyLine(proto_ref=self._proto.outline)

    @outline.setter
    def outline(self, outline: PolyLine):
        self._proto.outline.CopyFrom(outline._proto)

    @property
    def holes(self) -> list[PolyLine]:
        return [PolyLine(proto_ref=hole) for hole in self._proto.holes]

    def add_hole(self, hole: PolyLine):
        self._proto.holes.append(hole._proto)

    def remove_hole(self, hole: PolyLine):
        self._proto.holes.remove(hole._proto)

    def bounding_box(self) -> Box2:
        if not self.outline.nodes:
            return Box2()

        min_x = math.inf
        min_y = math.inf
        max_x = -math.inf
        max_y = -math.inf

        for node in self.outline:
            if node.has_point:
                min_x = min(min_x, node.point.x)
                min_y = min(min_y, node.point.y)
                max_x = max(max_x, node.point.x)
                max_y = max(max_y, node.point.y)
            elif node.has_arc:
                box = node.arc.bounding_box()
                min_x = min(min_x, box.pos.x)
                min_y = min(min_y, box.pos.y)
                max_x = max(max_x, box.pos.x + box.size.x)
                max_y = max(max_y, box.pos.y + box.size.y)

        return Box2.from_pos_size(
            Vector2.from_xy(int(min_x), int(min_y)),
            Vector2.from_xy(int(max_x - min_x), int(max_y - min_y)),
        )

    def move(self, delta: Vector2):
        for node in self.outline:
            if node.has_point:
                node.point += delta
            elif node.has_arc:
                node.arc.start += delta
                node.arc.mid += delta
                node.arc.end += delta

        for hole in self.holes:
            for node in hole:
                if node.has_point:
                    node.point += delta
                elif node.has_arc:
                    node.arc.start += delta
                    node.arc.mid += delta
                    node.arc.end += delta

    def rotate(self, delta: Angle, center: Optional[Vector2] = None):
        if center is None:
            center = self.bounding_box().center()

        self.outline.rotate(delta, center)

        for hole in self.holes:
            hole.rotate(delta, center)

def arc_center(start: Vector2, mid: Vector2, end: Vector2) -> Optional[Vector2]:
    """
    Calculates the center of the arc.  Uses a different algorithm than KiCad so may have
    slightly different results.  The KiCad API preserves the start, middle, and end points of
    the arc, so any other properties such as the center point and angles must be calculated

    :return: The center of the arc, or None if the arc is degenerate
    """
    # TODO we may want to add an API call to get KiCad to calculate this for us,
    # for situations where matching KiCad's behavior exactly is important
    if start == end:
        return (start + mid) * 0.5

    def perpendicular_bisector(p1: Vector2, p2: Vector2):
        mid_point = (p1 + p2) * 0.5
        direction = p2 - p1
        perpendicular_direction = Vector2.from_xy(-direction.y, direction.x)
        return mid_point, perpendicular_direction

    mid1, dir1 = perpendicular_bisector(start, mid)
    mid2, dir2 = perpendicular_bisector(mid, end)

    det = float(dir1.x * dir2.y - dir1.y * dir2.x)

    if det == 0:
        return None

    # Intersect the two perpendicular bisectors to find the center
    t = ((mid2.x - mid1.x) * dir2.y - (mid2.y - mid1.y) * dir2.x) / det
    center = mid1 + (dir1 * t)

    return center

def arc_radius(start: Vector2, mid: Vector2, end: Vector2) -> float:
    """
    Calculates the radius of the arc.  Uses a different algorithm than KiCad so may have
    slightly different results.  The KiCad API preserves the start, middle, and end points of
    the arc, so any other properties such as the center point and angles must be calculated

    :return: The radius of the arc, or 0 if the arc is degenerate
    """
    # TODO we may want to add an API call to get KiCad to calculate this for us,
    # for situations where matching KiCad's behavior exactly is important
    center = arc_center(start, mid, end)
    if center is None:
        return 0

    return (start - center).length()

def normalize_angle_degrees(angle: float) -> float:
    """Normalizes an angle to fall within the range [0, 360)

    .. versionadded:: 0.3.0"""
    while angle < 0.0:
        angle += 360.0

    while angle >= 360.0:
        angle -= 360.0

    return angle

def normalize_angle_radians(angle: float) -> float:
    """Normalizes an angle to fall within the range [0, 2*pi)

    .. versionadded:: 0.3.0"""
    while angle < 0.0:
        angle += 2 * math.pi

    while angle >= 2 * math.pi:
        angle -= 2 * math.pi

    return angle

def arc_start_angle(start: Vector2, mid: Vector2, end: Vector2) -> Optional[float]:
    """Calculates the arc's starting angle in radians, normalized to [0, 2*pi)

    :return: The starting angle of the arc, or None if the arc is degenerate"""
    center = arc_center(start, mid, end)
    if center is None:
        return None

    return normalize_angle_radians((start - center).angle())

def arc_end_angle(start: Vector2, mid: Vector2, end: Vector2) -> Optional[float]:
    """Calculates the arc's ending angle in radians, normalized to [0, 2*pi)

    :return: The ending angle of the arc, or None if the arc is degenerate"""
    center = arc_center(start, mid, end)
    if center is None:
        return None

    angle = (end - center).angle()

    start_angle = arc_start_angle(start, mid, end)
    assert(start_angle is not None)

    if angle == start_angle:
        angle += 2 * math.pi

    return normalize_angle_radians(angle)

def arc_start_angle_degrees(start: Vector2, mid: Vector2, end: Vector2) -> Optional[float]:
    """Calculates the arc's starting angle in degrees, normalized to [0, 360)

    .. versionadded:: 0.3.0
    """
    center = arc_center(start, mid, end)
    if center is None:
        return None

    return normalize_angle_degrees((start - center).angle_degrees())

def arc_end_angle_degrees(start: Vector2, mid: Vector2, end: Vector2) -> Optional[float]:
    """Calculates the arc's ending angle in degrees, normalized to [0, 360)

    .. versionadded:: 0.3.0
    """
    center = arc_center(start, mid, end)
    if center is None:
        return None

    angle = (end - center).angle_degrees()

    start_angle = arc_start_angle(start, mid, end)
    assert(start_angle is not None)

    if angle == start_angle:
        angle += 360

    return normalize_angle_degrees(angle)

```

# board.py
```board.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from time import sleep
from typing import List, Dict, Union, Iterable, Optional, Sequence, cast, overload
from google.protobuf.empty_pb2 import Empty

from kipy.board_types import (
    ArcTrack,
    BoardEditorAppearanceSettings,
    BoardItem,
    BoardText,
    BoardTextBox,
    Dimension,
    FootprintInstance,
    Net,
    Pad,
    BoardShape,
    Track,
    Via,
    Zone,
    to_concrete_board_shape,
    to_concrete_dimension,
    unwrap
)
from kipy.client import ApiError, KiCadClient
from kipy.common_types import Color, Commit, TitleBlockInfo, TextAttributes
from kipy.geometry import Box2, PolygonWithHoles, Vector2
from kipy.project import Project, NetClass
from kipy.proto.board import board_types_pb2
from kipy.proto.common.commands import editor_commands_pb2, project_commands_pb2
from kipy.proto.common.envelope_pb2 import ApiStatusCode
from kipy.util import pack_any
from kipy.wrapper import Item, Wrapper

from kipy.proto.common.commands import Ping
from kipy.proto.common.types import DocumentSpecifier, KIID, KiCadObjectType, base_types_pb2
from kipy.proto.common.commands.editor_commands_pb2 import (
    BeginCommit, BeginCommitResponse, CommitAction,
    EndCommit, EndCommitResponse,
    CreateItems, CreateItemsResponse,
    UpdateItems, UpdateItemsResponse,
    GetItems, GetItemsResponse,
    DeleteItems, DeleteItemsResponse,
    HitTest, HitTestResponse, HitTestResult
)
from kipy.proto.board import board_pb2
from kipy.proto.board import board_commands_pb2

# Re-exported protobuf enum types
from kipy.proto.board.board_pb2 import (    # noqa
    BoardLayerClass
)
from kipy.proto.board.board_types_pb2 import ( #noqa
    BoardLayer
)
from kipy.proto.board.board_commands_pb2 import ( #noqa
    BoardOriginType
)

class BoardLayerGraphicsDefaults(Wrapper):
    """The default properties for graphic items added on a given class of board layer"""
    def __init__(self, proto: Optional[board_pb2.BoardLayerGraphicsDefaults] = None):
        self._proto = board_pb2.BoardLayerGraphicsDefaults()

        if proto is not None:
            self._proto.CopyFrom(proto)
    @property
    def layer(self) -> board_pb2.BoardLayerClass.ValueType:
        """The layer class that these defaults apply to"""
        return self._proto.layer

    @layer.setter
    def layer(self, value: board_pb2.BoardLayerClass.ValueType):
        self._proto.layer = value

    @property
    def line_thickness(self) -> int:
        return self._proto.line_thickness.value_nm

    @line_thickness.setter
    def line_thickness(self, value: int):
        self._proto.line_thickness.value_nm = value

    @property
    def text(self) -> TextAttributes:
        return TextAttributes(self._proto.text)

class BoardStackupDielectricProperties(Wrapper):
    def __init__(self, proto: Optional[board_pb2.BoardStackupDielectricProperties] = None):
        self._proto = board_pb2.BoardStackupDielectricProperties()
        if proto:
            self._proto.CopyFrom(proto)

    @property
    def epsilon_r(self) -> float:
        return self._proto.epsilon_r

    @epsilon_r.setter
    def epsilon_r(self, epsilon_r: float):
        self._proto.epsilon_r = epsilon_r

    @property
    def loss_tangent(self) -> float:
        return self._proto.loss_tangent

    @loss_tangent.setter
    def loss_tangent(self, loss_tangent: float):
        self._proto.loss_tangent = loss_tangent

    @property
    def material_name(self) -> str:
        return self._proto.material_name

    @material_name.setter
    def material_name(self, name: str):
        self._proto.material_name = name

    @property
    def thickness(self) -> int:
        return self._proto.thickness.value_nm

    @thickness.setter
    def thickness(self, thickness: int):
        self._proto.thickness.value_nm = thickness


class BoardStackupDielectricLayer(Wrapper):
    def __init__(self, proto: Optional[board_pb2.BoardStackupDielectricLayer] = None):
        self._proto = board_pb2.BoardStackupDielectricLayer()
        if proto:
            self._proto.CopyFrom(proto)

    @property
    def layers(self) -> List[BoardStackupDielectricProperties]:
        """Each dielectric layer may be made up of one or more sub-layers with different properties"""
        return [BoardStackupDielectricProperties(layer) for layer in self._proto.layer]


class BoardStackupLayer(Wrapper):
    def __init__(self, proto: Optional[board_pb2.BoardStackupLayer] = None):
        self._proto = board_pb2.BoardStackupLayer()
        if proto:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return (
            f"BoardStackupLayer(layer={BoardLayer.Name(self.layer)}, user_name={self.user_name},"
            f"thickness={self.thickness}, enabled={self.enabled}, type={self.type},"
            f"material_name={self.material_name})"
        )

    @property
    def thickness(self) -> int:
        """The total thickness of this layer, in nanometers.  If this is a dielectric layer, this
        thickness may be the sum of multiple sub-layers."""
        return self._proto.thickness.value_nm

    @thickness.setter
    def thickness(self, value: int):
        self._proto.thickness.value_nm = value

    @property
    def layer(self) -> BoardLayer.ValueType:
        """The board layer this stackup entry corresponds to, or BL_UNDEFINED if this entry is
        a dielectric layer"""
        return self._proto.layer

    @layer.setter
    def layer(self, value: BoardLayer.ValueType):
        self._proto.layer = value

    @property
    def enabled(self) -> bool:
        return self._proto.enabled

    @enabled.setter
    def enabled(self, value: bool):
        self._proto.enabled = value

    @property
    def type(self) -> board_pb2.BoardStackupLayerType.ValueType:
        return self._proto.type

    @type.setter
    def type(self, value: board_pb2.BoardStackupLayerType.ValueType):
        self._proto.type = value

    @property
    def dielectric(self) -> BoardStackupDielectricLayer:
        return BoardStackupDielectricLayer(self._proto.dielectric)

    @dielectric.setter
    def dielectric(self, value: BoardStackupDielectricLayer):
        self._proto.dielectric.CopyFrom(value.proto)

    @property
    def color(self) -> Color:
        return Color(self._proto.color)

    @color.setter
    def color(self, value: Color):
        self._proto.color.CopyFrom(value.proto)

    @property
    def material_name(self) -> str:
        return self._proto.material_name

    @material_name.setter
    def material_name(self, value: str):
        self._proto.material_name = value

    @property
    def user_name(self) -> str:
        """The name of the layer shown in the KiCad GUI, which may be a default value like "F.Cu"
        or may have been customized by the user. This field does not apply to dielectric layers."""
        return self._proto.user_name

    @user_name.setter
    def user_name(self, value: str):
        self._proto.user_name = value

class BoardStackup(Wrapper):
    def __init__(self, proto: Optional[board_pb2.BoardStackup] = None):
        self._proto = board_pb2.BoardStackup()
        if proto:
            self._proto.CopyFrom(proto)

    def __repr__(self) -> str:
        return f"BoardStackup(layers={self.layers})"

    @property
    def layers(self) -> List[BoardStackupLayer]:
        """The stackup layers, in order from top to bottom of the board"""
        return [BoardStackupLayer(layer) for layer in self._proto.layers]

class Board:
    def __init__(self, kicad: KiCadClient, document: DocumentSpecifier):
        """Represents an open board (.kicad_pcb) document in KiCad"""
        self._kicad = kicad
        self._doc = document

    def __repr__(self) -> str:
        return f"Board(filename={self.name})"

    @property
    def client(self) -> KiCadClient:
        """The KiCad client used to communicate with the API server"""
        return self._kicad

    @property
    def document(self) -> DocumentSpecifier:
        """The document specifier for the board"""
        return self._doc

    def get_project(self) -> Project:
        """Returns the project that this board is a part of"""
        return Project(self._kicad, self._doc)

    @property
    def name(self) -> str:
        """Returns the file name of the board"""
        return self._doc.board_filename

    def save(self):
        command = editor_commands_pb2.SaveDocument()
        command.document.CopyFrom(self._doc)
        self._kicad.send(command, Empty)

    def save_as(self, filename: str, overwrite: bool = False, include_project: bool = True):
        """Saves the board to a new file.

        :param filename: The path to save the board to
        :param overwrite: If True, the file will be overwritten if it already exists
        :param include_project: If True, the project will be saved along with the board
        """
        command = editor_commands_pb2.SaveCopyOfDocument()
        command.document.CopyFrom(self._doc)
        command.path = filename
        command.options.overwrite = overwrite
        command.options.include_project = include_project
        self._kicad.send(command, Empty)

    def revert(self):
        """Reverts the board to the last saved state"""
        command = editor_commands_pb2.RevertDocument()
        command.document.CopyFrom(self._doc)
        self._kicad.send(command, Empty)

    def begin_commit(self) -> Commit:
        """Begins a commit transaction on the board, returning a Commit object that can be used to
        push or drop (cancel) the commit.  Each commit represents a set of changes that can be
        undone or redone as a single operation.

        If you do not call begin_commit, any changes made to the board will be committed
        immediately, which will result in multiple steps being added to the undo history.

        If you call begin_commit, changes made to the board will not be reflected in the editor
        until you call push_commit.  This allows you to group multiple changes into a single undo
        step.
        """
        command = BeginCommit()
        return Commit(self._kicad.send(command, BeginCommitResponse).id)

    def push_commit(self, commit: Commit, message: str = ""):
        """If a commit is open, pushes the changes to the board and closes the commit.  This will
        result in a single undo step being added to the undo history."""
        command = EndCommit()
        command.id.CopyFrom(commit.id)
        command.action = CommitAction.CMA_COMMIT
        command.message = message
        self._kicad.send(command, EndCommitResponse)

    def drop_commit(self, commit: Commit):
        """Cancel a commit, discarding any changes made since the commit was opened"""
        command = EndCommit()
        command.id.CopyFrom(commit.id)
        command.action = CommitAction.CMA_DROP
        self._kicad.send(command, EndCommitResponse)

    def create_items(self, items: Union[Wrapper, Iterable[Wrapper]]) -> List[Wrapper]:
        command = CreateItems()
        command.header.document.CopyFrom(self._doc)

        if isinstance(items, Wrapper):
            command.items.append(pack_any(items.proto))
        else:
            command.items.extend([pack_any(i.proto) for i in items])

        return [
            unwrap(result.item)
            for result in self._kicad.send(command, CreateItemsResponse).created_items
        ]

    def _to_concrete_items(self, items: Sequence[Wrapper]) -> List[BoardItem]:
        items_converted = []
        for it in items:
            if isinstance(it, BoardShape):
                items_converted.append(to_concrete_board_shape(cast(BoardShape, it)))
            elif isinstance(it, Dimension):
                items_converted.append(to_concrete_dimension(cast(Dimension, it)))
            else:
                items_converted.append(it)
        return items_converted

    def get_items(
        self, types: Union[KiCadObjectType.ValueType, Sequence[KiCadObjectType.ValueType]]
    ) -> Sequence[Wrapper]:
        """Retrieves items from the board, optionally filtering to a single or set of types"""
        command = GetItems()
        command.header.document.CopyFrom(self._doc)

        if isinstance(types, int):
            command.types.append(types)
        else:
            command.types.extend(types)

        return self._to_concrete_items(
            [unwrap(item) for item in self._kicad.send(command, GetItemsResponse).items]
        )

    def get_tracks(self) -> Sequence[Union[Track, ArcTrack]]:
        """Retrieves all tracks and arc tracks on the board"""
        return [
            cast(Track, item) if isinstance(item, Track) else cast(ArcTrack, item)
            for item in self.get_items(
                types=[KiCadObjectType.KOT_PCB_TRACE, KiCadObjectType.KOT_PCB_ARC]
            )
        ]

    def get_vias(self) -> Sequence[Via]:
        """Retrieves all vias on the board"""
        return [cast(Via, item) for item in self.get_items(types=[KiCadObjectType.KOT_PCB_VIA])]

    def get_pads(self) -> Sequence[Pad]:
        """Retrieves all pads on the board (note that pads belong to footprints, not the board
        itself)"""
        return [cast(Pad, item) for item in self.get_items(types=[KiCadObjectType.KOT_PCB_PAD])]

    def get_footprints(self) -> Sequence[FootprintInstance]:
        """Retrieves all footprints on the board"""
        return [
            cast(FootprintInstance, item)
            for item in self.get_items(types=[KiCadObjectType.KOT_PCB_FOOTPRINT])
        ]

    def get_shapes(self) -> Sequence[BoardShape]:
        """Retrieves all graphic shapes (not including tracks or text) on the board"""
        return [
            item
            for item in (
                to_concrete_board_shape(cast(BoardShape, item))
                for item in self.get_items(types=[KiCadObjectType.KOT_PCB_SHAPE])
            )
            if item is not None
        ]

    def get_dimensions(self) -> Sequence[Dimension]:
        """Retrieves all dimension objects on the board"""
        return [
            item
            for item in (
                to_concrete_dimension(cast(Dimension, item))
                for item in self.get_items(types=[KiCadObjectType.KOT_PCB_DIMENSION])
            )
            if item is not None
        ]

    def get_text(self) -> Sequence[Union[BoardText, BoardTextBox]]:
        """Retrieves all text objects on the board"""
        return [
            cast(BoardText, item) if isinstance(item, BoardText) else cast(BoardTextBox, item)
            for item in self.get_items(
                types=[KiCadObjectType.KOT_PCB_TEXT, KiCadObjectType.KOT_PCB_TEXTBOX]
            )
        ]

    def get_zones(self) -> Sequence[Zone]:
        """Retrieves all zones (including rule areas and graphic zones) on the board"""
        return [cast(Zone, item) for item in self.get_items(types=[KiCadObjectType.KOT_PCB_ZONE])]

    def get_as_string(self) -> str:
        """Returns the board as a string in KiCad's board file format"""
        command = editor_commands_pb2.SaveDocumentToString()
        command.document.CopyFrom(self._doc)
        return self._kicad.send(command, editor_commands_pb2.SavedDocumentResponse).contents

    def get_selection_as_string(self) -> str:
        """Returns the current selection as a string in KiCad's board file format"""
        command = editor_commands_pb2.SaveSelectionToString()
        return self._kicad.send(command, editor_commands_pb2.SavedSelectionResponse).contents

    def update_items(self, items: Union[BoardItem, Sequence[BoardItem]]) -> List[BoardItem]:
        """Updates the properties of one or more items on the board.  The items must already exist
        on the board, and are matched by internal UUID.  All other properties of the items are
        updated from those passed in this call.

        Returns the updated items, which may be different from the input items if any updates
        failed to apply (for example, if any properties were out of range and were clamped)"""
        command = UpdateItems()
        command.header.document.CopyFrom(self._doc)

        if isinstance(items, BoardItem):
            command.items.append(pack_any(items.proto))
        else:
            command.items.extend([pack_any(i.proto) for i in items])

        if len(command.items) == 0:
            return []

        return self._to_concrete_items(
            [
                unwrap(result.item)
                for result in self._kicad.send(
                    command, UpdateItemsResponse
                ).updated_items
            ]
        )

    def remove_items(self, items: Union[BoardItem, Sequence[BoardItem]]):
        """Deletes one or more items from the board"""
        command = DeleteItems()
        command.header.document.CopyFrom(self._doc)

        if isinstance(items, BoardItem):
            command.item_ids.append(items.id)
        else:
            command.item_ids.extend([item.id for item in items])

        if len(command.item_ids) == 0:
            return

        self._kicad.send(command, DeleteItemsResponse)

    def get_nets(
        self, netclass_filter: Optional[Union[str, Sequence[str]]] = None
    ) -> Sequence[Net]:
        """Retrieves all nets on the board, optionally filtering by net class"""
        command = board_commands_pb2.GetNets()
        command.board.CopyFrom(self._doc)

        if isinstance(netclass_filter, str):
            command.netclass_filter.append(netclass_filter)
        elif netclass_filter is not None:
            command.netclass_filter.extend(netclass_filter)

        return [
            Net(net)
            for net in self._kicad.send(command, board_commands_pb2.NetsResponse).nets
        ]

    def get_netclass_for_nets(self, nets: Union[Net, Sequence[Net]]) -> Dict[str, NetClass]:
        """Retrieves the net class for one or more nets on the board"""
        cmd = board_commands_pb2.GetNetClassForNets()
        if isinstance(nets, Net):
            cmd.net.append(nets.proto)
        else:
            cmd.net.extend([net.proto for net in nets])

        response = self._kicad.send(cmd, board_commands_pb2.NetClassForNetsResponse)
        return {key: NetClass(value) for key, value in response.classes.items()}

    def get_selection(
        self,
        types: Optional[
            Union[KiCadObjectType.ValueType, Sequence[KiCadObjectType.ValueType]]
        ] = None,
    ) -> Sequence[Wrapper]:
        cmd = editor_commands_pb2.GetSelection()
        cmd.header.document.CopyFrom(self._doc)

        if isinstance(types, int):
            cmd.types.append(types)
        else:
            cmd.types.extend(types or [])

        return self._to_concrete_items([
            unwrap(item)
            for item in self._kicad.send(
                cmd, editor_commands_pb2.SelectionResponse
            ).items
        ])

    def add_to_selection(
        self, items: Union[BoardItem, Sequence[BoardItem]]
    ) -> Sequence[Wrapper]:
        """Adds one or more items to the current selection on the board

        :param items: The items to add to the selection
        :return: The updated selection
        """
        cmd = editor_commands_pb2.AddToSelection()
        cmd.header.document.CopyFrom(self._doc)

        if isinstance(items, BoardItem):
            cmd.items.append(items.id)
        else:
            cmd.items.extend([i.id for i in items])

        return [
            unwrap(item)
            for item in self._kicad.send(
                cmd, editor_commands_pb2.SelectionResponse
            ).items
        ]

    def remove_from_selection(
        self, items: Union[BoardItem, Sequence[BoardItem]]
    ) -> Sequence[Wrapper]:
        """Removes one or more items from the current selection on the board

        :param items: The items to remove from the selection
        :return: The updated selection
        """
        cmd = editor_commands_pb2.RemoveFromSelection()
        cmd.header.document.CopyFrom(self._doc)

        if isinstance(items, BoardItem):
            cmd.items.append(items.id)
        else:
            cmd.items.extend([i.id for i in items])

        return [
            unwrap(item)
            for item in self._kicad.send(
                cmd, editor_commands_pb2.SelectionResponse
            ).items
        ]

    def clear_selection(self):
        """Clears the current selection on the board"""
        cmd = editor_commands_pb2.ClearSelection()
        cmd.header.document.CopyFrom(self._doc)
        self._kicad.send(cmd, Empty)

    def get_stackup(self) -> BoardStackup:
        """Retrieves the stackup for the board"""
        command = board_commands_pb2.GetBoardStackup()
        command.board.CopyFrom(self._doc)
        return BoardStackup(
            self._kicad.send(command, board_commands_pb2.BoardStackupResponse).stackup
        )

    def get_graphics_defaults(self) -> Dict[int, BoardLayerGraphicsDefaults]:
        """Retrieves the default graphics properties for each layer class on the board"""
        cmd = board_commands_pb2.GetGraphicsDefaults()
        cmd.board.CopyFrom(self._doc)
        reply = self._kicad.send(cmd, board_commands_pb2.GraphicsDefaultsResponse)
        return {
            board_pb2.BoardLayerClass.BLC_SILKSCREEN:  BoardLayerGraphicsDefaults(reply.defaults.layers[0]),
            board_pb2.BoardLayerClass.BLC_COPPER:      BoardLayerGraphicsDefaults(reply.defaults.layers[1]),
            board_pb2.BoardLayerClass.BLC_EDGES:       BoardLayerGraphicsDefaults(reply.defaults.layers[2]),
            board_pb2.BoardLayerClass.BLC_COURTYARD:   BoardLayerGraphicsDefaults(reply.defaults.layers[3]),
            board_pb2.BoardLayerClass.BLC_FABRICATION: BoardLayerGraphicsDefaults(reply.defaults.layers[4]),
            board_pb2.BoardLayerClass.BLC_OTHER:       BoardLayerGraphicsDefaults(reply.defaults.layers[5])
        }

    def get_title_block_info(self) -> TitleBlockInfo:
        """Retrieves the title block information for the board"""
        cmd = editor_commands_pb2.GetTitleBlockInfo()
        cmd.document.CopyFrom(self._doc)
        return TitleBlockInfo(self._kicad.send(cmd, base_types_pb2.TitleBlockInfo))

    def get_origin(self, origin_type: board_commands_pb2.BoardOriginType.ValueType) -> Vector2:
        """Retrieves the specified (grid or drill/place) board origin

        .. versionadded:: 0.3.0"""
        cmd = board_commands_pb2.GetBoardOrigin()
        cmd.board.CopyFrom(self._doc)
        cmd.type = origin_type
        return Vector2(self._kicad.send(cmd, base_types_pb2.Vector2))

    def set_origin(self, origin_type: board_commands_pb2.BoardOriginType.ValueType,
                   origin: Vector2):
        """Sets the specified (grid or drill/place) board origin

        .. versionadded:: 0.3.0"""
        cmd = board_commands_pb2.SetBoardOrigin()
        cmd.board.CopyFrom(self._doc)
        cmd.type = origin_type
        cmd.origin.CopyFrom(origin.proto)
        self._kicad.send(cmd, Empty)

    @overload
    def expand_text_variables(self, text: str) -> str:
        ...

    @overload
    def expand_text_variables(self, text: List[str]) -> List[str]:
        ...

    def expand_text_variables(self, text: Union[str, List[str]]) -> Union[str, List[str]]:
        """Expands text variables in a string or list of strings.  Any text variables that do not
        exist will be left as-is in the output."""
        command = project_commands_pb2.ExpandTextVariables()
        command.document.CopyFrom(self._doc)
        if isinstance(text, list):
            command.text.extend(text)
        else:
            command.text.append(text)
        response = self._kicad.send(command, project_commands_pb2.ExpandTextVariablesResponse)
        return (
            [text for text in response.text]
            if isinstance(text, list)
            else response.text[0]
            if len(response.text) > 0
            else ""
        )

    @overload
    def get_item_bounding_box(
        self, items: BoardItem, include_text: bool = False
    ) -> Optional[Box2]: ...

    @overload
    def get_item_bounding_box(
        self, items: Sequence[BoardItem], include_text: bool = False
    ) -> List[Optional[Box2]]: ...

    def get_item_bounding_box(
        self,
        items: Union[BoardItem, Sequence[BoardItem]],
        include_text: bool = False
    ) -> Union[Optional[Box2], List[Optional[Box2]]]:
        """Gets the KiCad-calculated bounding box for an item or items, returning None if the item
        does not exist or has no bounding box"""
        cmd = editor_commands_pb2.GetBoundingBox()
        cmd.header.document.CopyFrom(self._doc)
        cmd.mode = (
            editor_commands_pb2.BoundingBoxMode.BBM_ITEM_AND_CHILD_TEXT
            if include_text
            else editor_commands_pb2.BoundingBoxMode.BBM_ITEM_ONLY
        )

        if isinstance(items, BoardItem):
            cmd.items.append(items.id)
        else:
            cmd.items.extend([i.id for i in items])

        response = self._kicad.send(cmd, editor_commands_pb2.GetBoundingBoxResponse)

        if isinstance(items, BoardItem):
            return Box2.from_proto(response.boxes[0]) if len(response.boxes) == 1 else None

        item_to_bbox = {item.value: bbox for item, bbox in zip(response.items, response.boxes)}
        return [
            Box2.from_proto(box)
            for box in (item_to_bbox.get(item.id.value, None) for item in items)
            if box is not None
        ]

    @overload
    def get_pad_shapes_as_polygons(
        self, pads: Pad, layer: BoardLayer.ValueType = BoardLayer.BL_F_Cu
    ) -> Optional[PolygonWithHoles]: ...

    @overload
    def get_pad_shapes_as_polygons(
        self, pads: Sequence[Pad], layer: BoardLayer.ValueType = BoardLayer.BL_F_Cu
    ) -> List[Optional[PolygonWithHoles]]: ...

    def get_pad_shapes_as_polygons(
        self, pads: Union[Pad, Sequence[Pad]], layer: BoardLayer.ValueType = BoardLayer.BL_F_Cu
    ) -> Union[Optional[PolygonWithHoles], List[Optional[PolygonWithHoles]]]:
        """Retrieves the polygonal shape of one or more pads on a given layer.  If a pad does not
        exist or has no polygonal shape on the given layer, None will be returned for that pad."""
        cmd = board_commands_pb2.GetPadShapeAsPolygon()
        cmd.board.CopyFrom(self._doc)
        cmd.layer = layer

        if isinstance(pads, Pad):
            cmd.pads.append(pads.id)
        else:
            cmd.pads.extend([pad.id for pad in pads])

        response = self._kicad.send(cmd, board_commands_pb2.PadShapeAsPolygonResponse)

        if isinstance(pads, Pad):
            return PolygonWithHoles(response.polygons[0]) if len(response.polygons) == 1 else None

        pad_to_polygon = {pad.value: polygon for pad, polygon in zip(response.pads, response.polygons)}
        return [
            PolygonWithHoles(p)
            for p in (pad_to_polygon.get(pad.id.value, None) for pad in pads)
            if p is not None
        ]

    def check_padstack_presence_on_layers(
        self,
        items: Union[BoardItem, Iterable[BoardItem]],
        layers: Union[board_types_pb2.BoardLayer.ValueType, Iterable[board_types_pb2.BoardLayer.ValueType]]
    ) -> Dict[BoardItem, Dict[board_types_pb2.BoardLayer.ValueType, bool]]:
        """Checks if the given items with padstacks (pads or vias) have content on the given layers.

        :param items: The items to check (one or more pads or vias).
        :param layers: The layer or layers to check for padstack presence.
        :return: A dictionary mapping each item to a dictionary of layers and their presence on
                 the given layer.

        .. versionadded:: 0.4.0 with KiCad 9.0.3
        """
        cmd = board_commands_pb2.CheckPadstackPresenceOnLayers()
        cmd.board.CopyFrom(self._doc)

        items_map = {}

        if isinstance(items, BoardItem):
            cmd.items.append(items.id)
            items_map[items.id.value] = items
        else:
            cmd.items.extend([item.id for item in items])
            items_map.update({item.id.value: item for item in items})

        if isinstance(layers, int):
            cmd.layers.append(layers)
        else:
            cmd.layers.extend(layers)

        response = self._kicad.send(cmd, board_commands_pb2.PadstackPresenceResponse)

        result = {}
        for entry in response.entries:
            if entry.item.value not in items_map:
                continue

            item = items_map[entry.item.value]
            layer = entry.layer
            presence = entry.presence is board_commands_pb2.PadstackPresence.PSP_PRESENT

            if item not in result:
                result[item] = {}

            result[item][layer] = presence

        return result

    def interactive_move(self, items: Union[KIID, Iterable[KIID]]):
        """Initiates an interactive move operation on one or more items on the board.  The user
        will be able to move the items interactively in the KiCad editor.  This is a blocking
        operation; this function will return immediately but future API calls will return AS_BUSY
        until the interactive move is complete."""
        cmd = board_commands_pb2.InteractiveMoveItems()
        cmd.board.CopyFrom(self._doc)

        if isinstance(items, KIID):
            cmd.items.append(items)
        else:
            cmd.items.extend(items)

        self._kicad.send(cmd, Empty)

    def refill_zones(self, block=True, max_poll_seconds: float = 30.0,
                     poll_interval_seconds: float = 0.5):
        """Refills all zones on the board.  If block is True, this function will block until the
        refill operation is complete.  If block is False, this function will return immediately,
        and future API calls will return AS_BUSY until the refill operation is complete."""
        cmd = board_commands_pb2.RefillZones()
        cmd.board.CopyFrom(self._doc)
        self._kicad.send(cmd, Empty)

        if not block:
            return

        # Zone fill is a blocking operation that can block the entire event loop.
        # To hide this from API users somewhat, do an initial busy loop here
        sleeps = 0

        while sleeps < max_poll_seconds:
            sleep(poll_interval_seconds)
            try:
                self._kicad.send(Ping(), Empty)
            except IOError:
                # transport-layer timeout
                continue
            except ApiError as e:
                if e.code == ApiStatusCode.AS_BUSY:
                    continue
                else:
                    raise e
            break

    def hit_test(self, item: Item, position: Vector2, tolerance: int = 0) -> bool:
        """Performs a hit test on a board item at a given position"""
        cmd = HitTest()
        cmd.header.document.CopyFrom(self._doc)
        cmd.id.CopyFrom(item.id)
        cmd.position.CopyFrom(position.proto)
        cmd.tolerance = tolerance
        return self._kicad.send(cmd, HitTestResponse).result == HitTestResult.HTR_HIT

    def get_visible_layers(self) -> Sequence[board_types_pb2.BoardLayer.ValueType]:
        cmd = board_commands_pb2.GetVisibleLayers()
        cmd.board.CopyFrom(self._doc)
        response = self._kicad.send(cmd, board_commands_pb2.BoardLayers)
        return response.layers

    def set_visible_layers(self, layers: Sequence[board_types_pb2.BoardLayer.ValueType]):
        cmd = board_commands_pb2.SetVisibleLayers()
        cmd.board.CopyFrom(self._doc)
        cmd.layers.extend(layers)
        self._kicad.send(cmd, Empty)

    def get_active_layer(self) -> board_types_pb2.BoardLayer.ValueType:
        cmd = board_commands_pb2.GetActiveLayer()
        cmd.board.CopyFrom(self._doc)
        response = self._kicad.send(cmd, board_commands_pb2.BoardLayerResponse)
        return response.layer

    def set_active_layer(self, layer: board_types_pb2.BoardLayer.ValueType):
        cmd = board_commands_pb2.SetActiveLayer()
        cmd.board.CopyFrom(self._doc)
        cmd.layer = layer
        self._kicad.send(cmd, Empty)

    def get_editor_appearance_settings(self) -> BoardEditorAppearanceSettings:
        cmd = board_commands_pb2.GetBoardEditorAppearanceSettings()
        response = self._kicad.send(cmd, board_commands_pb2.BoardEditorAppearanceSettings)
        return BoardEditorAppearanceSettings(response)

    def set_editor_appearance_settings(self, settings: BoardEditorAppearanceSettings):
        cmd = board_commands_pb2.SetBoardEditorAppearanceSettings()
        cmd.settings.CopyFrom(settings.proto)
        self._kicad.send(cmd, Empty)

```

# errors.py
```errors.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from kipy.proto.common import ApiStatusCode

class ConnectionError(Exception):
    """Raised when a connection to KiCad cannot be established"""
    pass

class ApiError(Exception):
    """Raised when KiCad returns an error from an API call.  This indicates that the communcation
    was successful, but the API call failed for some reason."""
    def __init__(self, message: str, raw_message: str = "",
                 code: ApiStatusCode.ValueType = ApiStatusCode.AS_BAD_REQUEST):
         super().__init__(message)
         self._raw_message = raw_message
         self._code = code

    @property
    def code(self) -> ApiStatusCode.ValueType:
        return self._code

    @property
    def raw_message(self) -> str:
        return self.raw_message

class FutureVersionError(Exception):
    """Raised when a version check shows that kicad-python is talking to a version of KiCad
    newer than the one it was built against"""
    pass

```

# client.py
```client.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import pynng
from typing import TypeVar

from google.protobuf.message import Message

from kipy.errors import ApiError, ConnectionError
from kipy.proto.common import ApiRequest, ApiResponse, ApiStatusCode

class KiCadClient:
    def __init__(self, socket_path: str, client_name: str, kicad_token: str, timeout_ms: int):
        self._socket_path = socket_path
        self._client_name = client_name
        self._kicad_token = kicad_token
        self._timeout_ms = timeout_ms
        self._connected = False

    def _connect(self):
        if self._connected:
            self._conn.close()

        try:
            self._conn = pynng.Req0(dial=self._socket_path, block_on_dial=True,
                                    send_timeout=self._timeout_ms, recv_timeout=self._timeout_ms)
            self._connected = True
        except pynng.exceptions.NNGException as e:
            self._connected = False
            raise ConnectionError(f"Failed to connect to KiCad: {e}") from None

    @property
    def connected(self):
        return self._connected

    R = TypeVar('R', bound=Message)

    def send(self, command: Message, response_type: type[R]) -> R:
        if not self._connected:
            self._connect()

        envelope = ApiRequest()
        envelope.message.Pack(command)
        envelope.header.kicad_token = self._kicad_token
        envelope.header.client_name = self._client_name

        try:
            self._conn.send(envelope.SerializeToString())
        except pynng.exceptions.NNGException as e:
            raise ConnectionError(f"Failed to send command to KiCad: {e}") from None

        try:
            reply_data = self._conn.recv_msg()
        except pynng.exceptions.NNGException as e:
            raise ConnectionError(f"Error receiving reply from KiCad: {e}") from None

        reply = ApiResponse()
        reply.ParseFromString(reply_data.bytes)

        if reply.status.status == ApiStatusCode.AS_OK:
            response = response_type()

            if not reply.message.Unpack(response):
                raise ApiError(
                    f"Failed to unpack {response_type.__name__} from the response to {type(command).__name__}"
                )

            if self._kicad_token == "":
                self._kicad_token = reply.header.kicad_token

            return response
        else:
            raise ApiError(f"KiCad returned error: {reply.status.error_message}",
                           raw_message=reply.status.error_message, code=reply.status.status)

```

# proto/__init__.py
```proto/__init__.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# flake8: noqa

```

# proto/common/__init__.py
```proto/common/__init__.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# flake8: noqa

from .envelope_pb2 import *
from .types import *
from .commands import *
from .commands import *

```

# proto/common/types/__init__.py
```proto/common/types/__init__.py
# This program source code file is part of KiCad, a free EDA CAD application.
#
# Copyright (C) 2024 KiCad Developers
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

# flake8: noqa

from .base_types_pb2 import *
from .enums_pb2 import *
from .project_settings_pb2 import *
```

# proto/common/commands/__init__.py
```proto/common/commands/__init__.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# flake8: noqa

from .base_commands_pb2 import *
from .editor_commands_pb2 import *

```

# proto/board/__init__.py
```proto/board/__init__.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# flake8: noqa

from .board_types_pb2 import *

```

# util/proto.py
```util/proto.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from google.protobuf.any_pb2 import Any
from google.protobuf.message import Message, DecodeError

from kipy.proto.board import board_types_pb2
from kipy.proto.common.types import base_types_pb2

def pack_any(object: Message) -> Any:
    a = Any()
    a.Pack(object)
    return a

_any_urls = {
    "type.googleapis.com/kiapi.common.types.GraphicShape": base_types_pb2.GraphicShape,

    "type.googleapis.com/kiapi.board.types.Track": board_types_pb2.Track,
    "type.googleapis.com/kiapi.board.types.Arc": board_types_pb2.Arc,
    "type.googleapis.com/kiapi.board.types.Via": board_types_pb2.Via,
    "type.googleapis.com/kiapi.board.types.BoardText": board_types_pb2.BoardText,
    "type.googleapis.com/kiapi.board.types.BoardTextBox": board_types_pb2.BoardTextBox,
    "type.googleapis.com/kiapi.board.types.BoardGraphicShape": board_types_pb2.BoardGraphicShape,
    "type.googleapis.com/kiapi.board.types.Pad": board_types_pb2.Pad,
    "type.googleapis.com/kiapi.board.types.Zone": board_types_pb2.Zone,
    "type.googleapis.com/kiapi.board.types.Dimension": board_types_pb2.Dimension,
    "type.googleapis.com/kiapi.board.types.ReferenceImage": board_types_pb2.ReferenceImage,
    "type.googleapis.com/kiapi.board.types.Group": board_types_pb2.Group,
    "type.googleapis.com/kiapi.board.types.Field": board_types_pb2.Field,
    "type.googleapis.com/kiapi.board.types.FootprintInstance": board_types_pb2.FootprintInstance,
    "type.googleapis.com/kiapi.board.types.Footprint3DModel": board_types_pb2.Footprint3DModel
}

def unpack_any(object: Any) -> Message:
    if len(object.type_url) == 0:
        raise ValueError("Can't unpack empty Any protobuf message")

    type = _any_urls.get(object.type_url, None)
    if type is None:
        raise NotImplementedError(f"Missing type mapping for {object.type_url}, can't unpack it")

    concrete = type()
    try:
        object.Unpack(concrete)
    except DecodeError:
        raise ValueError(f"Can't unpack {object.type_url}.  Incompatible change on KiCad side?") from None
    return concrete

```

# util/__init__.py
```util/__init__.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# flake8: noqa

from .units import from_mm, to_mm
from .proto import pack_any, unpack_any

```

# util/board_layer.py
```util/board_layer.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from kipy.proto.board.board_types_pb2 import BoardLayer

CANONICAL_LAYER_NAMES = {
    BoardLayer.BL_F_Cu: "F.Cu",
    BoardLayer.BL_In1_Cu: "In1.Cu",
    BoardLayer.BL_In2_Cu: "In2.Cu",
    BoardLayer.BL_In3_Cu: "In3.Cu",
    BoardLayer.BL_In4_Cu: "In4.Cu",
    BoardLayer.BL_In5_Cu: "In5.Cu",
    BoardLayer.BL_In6_Cu: "In6.Cu",
    BoardLayer.BL_In7_Cu: "In7.Cu",
    BoardLayer.BL_In8_Cu: "In8.Cu",
    BoardLayer.BL_In9_Cu: "In9.Cu",
    BoardLayer.BL_In10_Cu: "In10.Cu",
    BoardLayer.BL_In11_Cu: "In11.Cu",
    BoardLayer.BL_In12_Cu: "In12.Cu",
    BoardLayer.BL_In13_Cu: "In13.Cu",
    BoardLayer.BL_In14_Cu: "In14.Cu",
    BoardLayer.BL_In15_Cu: "In15.Cu",
    BoardLayer.BL_In16_Cu: "In16.Cu",
    BoardLayer.BL_In17_Cu: "In17.Cu",
    BoardLayer.BL_In18_Cu: "In18.Cu",
    BoardLayer.BL_In19_Cu: "In19.Cu",
    BoardLayer.BL_In20_Cu: "In20.Cu",
    BoardLayer.BL_In21_Cu: "In21.Cu",
    BoardLayer.BL_In22_Cu: "In22.Cu",
    BoardLayer.BL_In23_Cu: "In23.Cu",
    BoardLayer.BL_In24_Cu: "In24.Cu",
    BoardLayer.BL_In25_Cu: "In25.Cu",
    BoardLayer.BL_In26_Cu: "In26.Cu",
    BoardLayer.BL_In27_Cu: "In27.Cu",
    BoardLayer.BL_In28_Cu: "In28.Cu",
    BoardLayer.BL_In29_Cu: "In29.Cu",
    BoardLayer.BL_In30_Cu: "In30.Cu",
    BoardLayer.BL_B_Cu: "B.Cu",
    BoardLayer.BL_B_Adhes: "B.Adhes",
    BoardLayer.BL_F_Adhes: "F.Adhes",
    BoardLayer.BL_B_Paste: "B.Paste",
    BoardLayer.BL_F_Paste: "F.Paste",
    BoardLayer.BL_B_SilkS: "B.SilkS",
    BoardLayer.BL_F_SilkS: "F.SilkS",
    BoardLayer.BL_B_Mask: "B.Mask",
    BoardLayer.BL_F_Mask: "F.Mask",
    BoardLayer.BL_Dwgs_User: "Dwgs.User",
    BoardLayer.BL_Cmts_User: "Cmts.User",
    BoardLayer.BL_Eco1_User: "Eco1.User",
    BoardLayer.BL_Eco2_User: "Eco2.User",
    BoardLayer.BL_Edge_Cuts: "Edge.Cuts",
    BoardLayer.BL_Margin: "Margin",
    BoardLayer.BL_F_CrtYd: "F.CrtYd",
    BoardLayer.BL_B_CrtYd: "B.CrtYd",
    BoardLayer.BL_F_Fab: "F.Fab",
    BoardLayer.BL_B_Fab: "B.Fab",
    BoardLayer.BL_User_1: "User.1",
    BoardLayer.BL_User_2: "User.2",
    BoardLayer.BL_User_3: "User.3",
    BoardLayer.BL_User_4: "User.4",
    BoardLayer.BL_User_5: "User.5",
    BoardLayer.BL_User_6: "User.6",
    BoardLayer.BL_User_7: "User.7",
    BoardLayer.BL_User_8: "User.8",
    BoardLayer.BL_User_9: "User.9",
    BoardLayer.BL_Rescue: "Rescue",
    BoardLayer.BL_User_10: "User.10",
    BoardLayer.BL_User_11: "User.11",
    BoardLayer.BL_User_12: "User.12",
    BoardLayer.BL_User_13: "User.13",
    BoardLayer.BL_User_14: "User.14",
    BoardLayer.BL_User_15: "User.15",
    BoardLayer.BL_User_16: "User.16",
    BoardLayer.BL_User_17: "User.17",
    BoardLayer.BL_User_18: "User.18",
    BoardLayer.BL_User_19: "User.19",
    BoardLayer.BL_User_20: "User.20",
    BoardLayer.BL_User_21: "User.21",
    BoardLayer.BL_User_22: "User.22",
    BoardLayer.BL_User_23: "User.23",
    BoardLayer.BL_User_24: "User.24",
    BoardLayer.BL_User_25: "User.25",
    BoardLayer.BL_User_26: "User.26",
    BoardLayer.BL_User_27: "User.27",
    BoardLayer.BL_User_28: "User.28",
    BoardLayer.BL_User_29: "User.29",
    BoardLayer.BL_User_30: "User.30",
    BoardLayer.BL_User_31: "User.31",
    BoardLayer.BL_User_32: "User.32",
    BoardLayer.BL_User_33: "User.33",
    BoardLayer.BL_User_34: "User.34",
    BoardLayer.BL_User_35: "User.35",
    BoardLayer.BL_User_36: "User.36",
    BoardLayer.BL_User_37: "User.37",
    BoardLayer.BL_User_38: "User.38",
    BoardLayer.BL_User_39: "User.39",
    BoardLayer.BL_User_40: "User.40",
    BoardLayer.BL_User_41: "User.41",
    BoardLayer.BL_User_42: "User.42",
    BoardLayer.BL_User_43: "User.43",
    BoardLayer.BL_User_44: "User.44",
    BoardLayer.BL_User_45: "User.45"
}

def is_copper_layer(layer: BoardLayer.ValueType) -> bool:
    """Checks if the given layer is a copper layer"""
    return layer in {
        BoardLayer.BL_F_Cu,
        BoardLayer.BL_B_Cu,
        BoardLayer.BL_In1_Cu,
        BoardLayer.BL_In2_Cu,
        BoardLayer.BL_In3_Cu,
        BoardLayer.BL_In4_Cu,
        BoardLayer.BL_In5_Cu,
        BoardLayer.BL_In6_Cu,
        BoardLayer.BL_In7_Cu,
        BoardLayer.BL_In8_Cu,
        BoardLayer.BL_In9_Cu,
        BoardLayer.BL_In10_Cu,
        BoardLayer.BL_In11_Cu,
        BoardLayer.BL_In12_Cu,
        BoardLayer.BL_In13_Cu,
        BoardLayer.BL_In14_Cu,
        BoardLayer.BL_In15_Cu,
        BoardLayer.BL_In16_Cu,
        BoardLayer.BL_In17_Cu,
        BoardLayer.BL_In18_Cu,
        BoardLayer.BL_In19_Cu,
        BoardLayer.BL_In20_Cu,
        BoardLayer.BL_In21_Cu,
        BoardLayer.BL_In22_Cu,
        BoardLayer.BL_In23_Cu,
        BoardLayer.BL_In24_Cu,
        BoardLayer.BL_In25_Cu,
        BoardLayer.BL_In26_Cu,
        BoardLayer.BL_In27_Cu,
        BoardLayer.BL_In28_Cu,
        BoardLayer.BL_In29_Cu,
        BoardLayer.BL_In30_Cu
    }

def canonical_name(layer: BoardLayer.ValueType) -> str:
    """Returns the canonical name of the given layer identifier.  This is the name that is used in
    the KiCad user interface if the user has not set a custom layer name, and in the KiCad file
    formats in various places."""
    return CANONICAL_LAYER_NAMES.get(layer, "Unknown")

def layer_from_canonical_name(name: str) -> BoardLayer.ValueType:
    """Returns the layer identifier for the given canonical layer name, or BL_UNKNOWN if the name
    is not recognized."""
    for layer, layer_name in CANONICAL_LAYER_NAMES.items():
        if layer_name == name:
            return layer
    return BoardLayer.BL_UNKNOWN

def iter_copper_layers():
    """Yields all copper layers."""
    for layer in CANONICAL_LAYER_NAMES.keys():
        if is_copper_layer(layer):
            yield layer

```

# util/units.py
```util/units.py
# Copyright The KiCad Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

def from_mm(value_mm: float) -> int:
    """
    KiCad uses several internal unit systems, but for the IPC API, all distance units are defined as
    64-bit nanometers
    :param value_mm: a quantity in millimeters
    :return: the quantity in KiCad API units
    """
    return int(value_mm * 1_000_000)

def to_mm(value_nm: int) -> float:
    """
    Converts a KiCad API length/distance value (in nanometers) to millimeters
    """
    return float(value_nm) / 1_000_000

```

